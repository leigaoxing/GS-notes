# 1. 背景描述

通过上一篇中网络模型中的IP层的介绍，我们知道网络层，可以实现两个主机之间的通信。但是这并不具体，因为，真正进行通信的实体是在主机中的进程，是一个主机中的一个进程与另外一个主机中的一个进程在交换数据。IP协议虽然能把数据报文送到目的主机，但是并没有交付给主机的具体应用进程。而端到端的通信才应该是应用进程之间的通信。

UDP，在传送数据前不需要先建立连接，远地的主机在收到UDP报文后也不需要给出任何确认。虽然UDP不提供可靠交付，但是正是因为这样，省去和很多的开销，使得它的速度比较快，比如一些对实时性要求较高的服务，就常常使用的是UDP。对应的应用层的协议主要有 DNS,TFTP,DHCP,SNMP,NFS 等。

TCP，提供面向连接的服务，在传送数据之前必须先建立连接，数据传送完成后要释放连接。因此TCP是一种可靠的的运输服务，但是正因为这样，不可避免的增加了许多的开销，比如确认，流量控制等。对应的应用层的协议主要有 SMTP,TELNET,HTTP,FTP 等。

# 2. 常用的熟知端口号

| 应用程序   | FTP   | TFTP | TELNET | SMTP | DNS  | HTTP | SSH  | MYSQL |
| ---------- | ----- | ---- | ------ | ---- | ---- | ---- | ---- | ----- |
| 熟知端口   | 21,20 | 69   | 23     | 25   | 53   | 80   | 22   | 3306  |
| 传输层协议 | TCP   | UDP  | TCP    | TCP  | UDP  | TCP  | TCP  | TCP   |

# 3. TCP 描述

**TCP（Transmission Control Protocol，传输控制协议）**是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，只简单的描述下这三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。

TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种端点我们叫作套接字（socket），它的定义为端口号拼接到IP地址即构成了套接字，例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80。

# 4. TCP 的工作流程

![](pics\TCP的工作流程.png)

# 5. TCP 报文首部

![](pics\TCP 首部.jpg)

![](pics\TCP Head.png)

TCP伪首部，看下面UDP的伪首部，工作机制是一样的。

1. **源端口**和**目的端口**，各占2个字节，分别写入源端口和目的端口；用于寻找发送端和接收端应用进程。
2. **序号**，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；
3. **确认号**，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；
4. **数据偏移**，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；
5. **保留**，占6位，保留今后使用，但目前应都位0；
6. **紧急URG**，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；
7. **确认ACK**，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；
8. **推送PSH**，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；
9. **复位RST**，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；
10. **同步SYN**，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；
11. **终止FIN**，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；
12. **窗口**，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；
13. **检验和**，占2字节，校验首部和数据这两部分；
14. **紧急指针**，占2字节，指出本报文段中的紧急数据的字节数；
15. **选项**，长度可变，定义一些其他的可选的参数。

# 6. 窗口

TCP 中很重要的一个概念非，那就是窗口（发送窗口和接收窗口）。

![](pics\窗口.png)

由于停止等待协议非常低效，于是衍生出窗口这个概念。上图为发送方维持的发送窗口，位于发送窗口的5个分组都可以连续发送出去而不需要等待对方的确认。没收到一个确认，就把发送窗口前移一个分组的位置，这大大提高了信道的利用率。

接收方不必发送每个分组的确认报文，而是采用累积的方式，也就是说，对按序到达的最后一个分组发送确认报文。

# 7. 超时重传

如果发送方等待一段时间后，还是没收到 ACK 确认报文，就会启动超时重传，这个等待的时间为重传超时时间 ( RTO,  Retransmission TimeOut)。

然而，RTO 的值不是固定的，这个时间总是略大于连接往返的时间 (RTT, Round Trip Time)。假设报文发送过去需要 5 秒，对方收到后发送确认报文回来也需要 5 秒，那么 RTT 就为 10 秒，那这 RTO 就要比 10 略大一些，那么 超过 RTO 之后还没有收到确认的报文就认为报文丢失了，就要重传。

# 7. TCP 连接建立

**TCB传输控制块**Transmission Control Block，存储每一个连接中的重要信息，如TCP连接表，到发送和接收缓存的指针，到重传队列的指针，当前的发送和接收序号。

![](pics\tcp 三次 握手.gif)

> 最初两端的 TCP 进程都处于 CLOSED 关闭状态，客户端 主动打开连接。(客户端、服务端关闭状态CLOSED——>服务端监听状态LISTEN——>客户端同步已发送状态SYN-SENT——>服务端同步收到状态SYN-RCVD——>客户端、服务端连接已建立状态ESTABLISHED)

![](pics\TCP三次握手.png)

1. TCP服务端进程先创建传输控制块 TCB，时刻准备接受客户端进程的连接请求，此时服务端就进入 LISTEN 状态。
2. ***(第一次握手)*** TCP 客户端进程先创建传输控制模块 TCB，然后向服务端发送连接请求报文，这是报文首部的同步位 SYN=1，同时选择一个初始序列号 Sequence Number = x，此时，TCP 客户端进入 SYN-SENT (同步已发送) 状态。***TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。***
3. ***(第二次握手)*** TCP 服务端接收到请求报文后，如果同意连接，则发送确认报文。确认报文中 ACK=1，SYN=1，Acknowledgement Number=x+1，同时也要为自己初始化一个序列号Sequence Number=y，此时，TCP 服务端进入 SYN-RCVD (同步收到) 状态。***这个报文也不能携带数据，但是同样要消耗一个序号***
4. ***(第三次握手)*** TCP客户进程收到确认后，还要向服务器给出确认。确认报文的 ACK=1， ack=y+1，自己的序号Sequence Number=x+1，此时，TCP连接建立，客户端进入ESTABLISHED (已建立连接) 状态。***TCP 规定，ACK 报文段可以携带数据，但是如果不携带数据则不消耗序列号***
5. 当服务端接收到客户端的确认后，也进入 ESTABLISHED 状态，此后双方就可以开始通信了。



# 8. 为什么客户端还要发送一次确认？可以二次握手吗？

***主要为了防止失效的连接请求报文段突然又传到服务端而产生错误的场景。***所谓“已失效的连接请求报文段”是这样产生的。正常来说，客户端发出连接请求，但因为连接请求报文丢失而未收到确认。于是客户端再次发出一次连接请求，后来收到了确认，建立了连接。数据传输完毕后，释放了连接，客户端一共发送了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，没有"已失效的连接请求报文段"。

现在假定一种异常情况，即客户端发出的第一个连接请求报文段并没有丢失，只是在某些网络节点长时间滞留了，以至于延误到连接释放以后的某个时间点才到达服务端。本来这个连接请求已经失效了，但是服务端收到此失效的连接请求报文段后，就误认为这是客户端又发出了一次新的连接请求。于是服务端又向客户端发出请求报文段，同意建立连接。假定不采用三次握手，那么只要服务端发出确认，连接就建立了。

由于现在客户端并没有发出连接建立的请求，因此不会理会服务端的确认，也不会向服务端发送数据，但是服务端却以为新的传输连接已经建立了，并一直等待客户端发来数据，这样服务端的许多资源就这样白白浪费了。

采用三次握手的办法可以防止上述现象的发生。比如在上述的场景下，客户端不向服务端的发出确认请求，服务端由于收不到确认，就知道客户端并没有要求建立连接。

# 9. Server 端易受到 SYN 攻击

服务端的资源分配是在 二次握手的时候分配的，而客户端的资源分配是在完成三次握手时分配的，所以服务端易受到 SYN 洪泛攻击。SYN 攻击就是 客户端 在短时间内 伪造大量不存在的 IP 地址，并向 Server 不断发送 SYN 包，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包长时间占用未连接队列，导致正常SYN请求因为队列满而被丢弃，从而引起网络阻塞甚至系统瘫痪。

防范 SYN 攻击措施：降低主机的等待时间使主机尽快释放半连接的占用，短时间受到某 IP 的重复 SYN 则丢弃后续请求。

# 10. TCP连接的释放

![](pics\TCP 四次挥手.gif)

> 数据传输结束后，通信的双方都可释放连接，客户端和服务端都处于 ESTABLISHED 状态。( 客户端、服务端连接建立状态 ESTABLISHED ——> 客户端终止等待1状态 FIN-WAIT-1——> 服务端关闭等待状态 CLOSED-WAIT——> 客户端终止等待2状态 FIN-WAIT-2——> 服务端租后确认状态 LAST-ACK——>客户端时间等待状态 TIME-WAIT——> 服务端、客户端关闭状态CLOSED)

![](pics\TCP四次挥手.png)

1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号Sequence Number=u (等于前面已经传送过来的数据的最后一个字节的序号加1)，此时，客户端进入 **FIN-WAIT-1** (终止等待1) 状态。***TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。***
2. 服务端收到连接释放报文，发出确认报文，ACK=1，Acknowledgement Number=u+1，并且带上自己的序列号 Sequence Number=v。此时，服务端就进入了**CLOSED-WAIT** (关闭等待) 状态。***TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。***
3. 客户端收到服务器的确认请求后，此时，客户端就进入**FIN-WAIT-2**（终止等待2）状态，等待服务器发送连接释放报文***（在这之前还需要接受服务器发送的最后的数据）***。
4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ACK=1，Acknowledgement Number=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 Sequence Number=w，此时，服务器就进入了**LAST-ACK**（最后确认）状态，等待客户端的确认。
5. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，Acknowledgement Number=w+1，而自己的序列号是 Sequence Number=u+1，此时，客户端就进入了**TIME-WAIT**（时间等待）状态。***注意此时TCP连接还没有释放，必须经过2\*MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。***
6. 服务器只要收到了客户端发出的确认，立即进入**CLOSED**状态。同样，撤销TCB后，就结束了这次的TCP连接。***可以看到，服务器结束TCP连接的时间要比客户端早一些***。

# 11. 为什么客户端最后还要等待2MSL？

MSL（Maximum Segment Lifetime）：最长报文段寿命，TCP允许不同的实现可以设置不同的MSL值。

第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

# 12. 为什么建立连接是三次握手，关闭连接是四次挥手？

因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

# 13. 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假想网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。

# 14. 如果已经建立了连接，但是客户端突然出现了故障怎么办？

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

# 15. UDP 描述

要使用UDP协议进行程序开发，我们必须首先得理解什么是什么是UDP？这里简单概括一下。

UDP（user datagram protocol）的中文叫用户数据报协议，属于传输层。UDP是面向非连接的协议，它不与对方建立连接，而是直接把我要发的数据报发给对方。所以UDP适用于一次传输数据量很少、对可靠性要求不高的或对实时性要求高的应用场景。正因为UDP无需建立类如三次握手的连接，而使得通信效率很高。

UDP的应用非常广泛，比如一些知名的应用层协议（SNMP、DNS）都是基于UDP的，想一想，如果SNMP使用的是TCP的话，每次查询请求都得进行三次握手，这个花费的时间估计是使用者不能忍受的，因为这会产生明显的卡顿。所以UDP就是SNMP的一个很好的选择了，要是查询过程发生丢包错包也没关系的，我们再发起一个查询就好了，因为丢包的情况不多，这样总比每次查询都卡顿一下更容易让人接受吧。

UDP通信的流程比较简单，因此要搭建这么一个常用的UDP通信框架也是比较简单的。以下是UDP的框架图。

![](pics\UDP 客户端服务端通信.jpg)

# 16. UDP的首部

下面的图 (图中的数字表示字节数(1 byte = 8bit)) 是一个UDP的检验和所需要用到的所有信息，包括三个部分：

1. UDP伪首部
2. UDP首部
3. UDP的数据部分（切记不要遗漏该部分，否则就~吐血了~）

![](pics\UDP首部.png)

**伪首部**：包含IP首部一些字段。其目的是让 UDP 两次检查数据是否已经正确到达目的地，只是单纯为了做校验用的。

还有一个概念十分重要，那就是**16位UDP总长度**，请注意该长度不是报文的总长度，而只是UDP（包括UDP头和数据部分）的总长度。

1. **端口号**：表示发送进程和接收进程。
2. **UDP长度**：指的是UDP首部和UDP数据的字节长度。该字段的最小值为8字节（发送一份0字节的UDP数据报是OK）。这个UDP长度是有冗余的。IP数据报长度指的是数据报全长，因此UDP数据报长度是全长减去IP首部的长度。 
3. **UDP检验和**：覆盖UDP首部和UDP数据。UDP检验和是一个端到端的检验和。它由发送端计算，然后由接收端验证。其目的是为了发现UDP首部和数据在发送端到接收端之间发生的任何改动。

# 17.  计算检验和(checksum)

 计算检验和（checksum）的过程很关键，主要分为以下几个步骤：

1. 把伪首部添加到UDP上；
2.  计算初始时是需要将检验和字段添零的；
3. 把所有位划分为16位（2字节）的字
4. 把所有16位的字相加，如果遇到进位，则将高于16字节的进位部分的值加到最低位上，举例，0xBB5E+0xFCED=0x1 B84B，则将1放到最低位，得到结果是0xB84C
5. 将所有字相加得到的结果应该为一个16位的数，将该数取反则可以得到检验和checksum。  

# 18. 小结与UDP的区别：

1. 基于连接与无连接；
2. 对系统资源的要求（TCP较多，UDP少）；
3. UDP程序结构较简单；
4. 流模式与数据报模式 ；
5. TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。  

# 参考

[TCP的三次握手与四次挥手（详解+动图）](https://blog.csdn.net/qzcsu/article/details/72861891)

[TCP 三次握手和四次挥手](https://www.cnblogs.com/Andya/p/7272462.html)

[TCP三次握手与四次挥手详解_](https://www.linuxidc.com/Linux/2019-06/159107.htm)

[Web开发应该知道的计算机网络知识 ](http://www.sohu.com/a/212580829_465223)

[Linux编程之UDP SOCKET全攻略](https://www.cnblogs.com/skyfsm/p/6287787.html)

[IP、TCP、UDP首部详解](https://www.jianshu.com/p/902e7d371acc)

[UDP全面分析](https://blog.csdn.net/tjcwt2011/article/details/78323297)

[字节、字、bit、byte的关系](https://blog.csdn.net/wanlixingzhe/article/details/7107923)

[TCP&UDP伪首部详解](https://blog.csdn.net/wufen_1981/article/details/1998518)

[二进制反码求和运算](https://www.cnblogs.com/jcchan/p/10400504.html)

[二进制反码求和校验算法](https://blog.csdn.net/dingmin1860/article/details/48268927)

[二进制反码求和](https://blog.csdn.net/u012063703/article/details/45850343)