# 一、设计模式是什么？



GOF设计模式《设计模式：可复用面向对象软件的基础》

# 二、从面向对象谈起

## 2.1 底层思维

底层思维：向下，如何把握机器底层从微观理解对象构造

1. 语言构造
2. 编译转换
3. 内存模型
4. 运行时机制

### 2.1.1 封装：隐藏内部实现

利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。

优点：

- 减少耦合：可以独立地开发、测试、优化、使用、理解和修改
- 减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块
- 有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能
- 提高软件的可重用性
- 降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的

### 2.1.2 继承：复用现有代码

继承实现了 **IS-A** 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。

继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。

Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 **向上转型** 。

### 2.1.3 多态：改写对象行为

多态分为编译时多态和运行时多态：

- 编译时多态主要指方法的重载
- 运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定

运行时多态有三个条件：

- 继承
- 覆盖（重写）
- 向上转型

## 2.2 抽象思维

深刻把握面向对象机制所带来的抽象意义，理解为 如何使用这些机制来表达现实世界，掌握什么是"好的面向对象的设计"。

抽象思维：向上，如何将我们的周围世界抽象为程序代码

1. 面向对象
2. 组件封装
3. 设计模式

4. 架构模式

# 三、如何解决软件设计中"变化"这种复杂性？

## 3.1 分解：

人们面对复杂性有一个常见的做法，即分而治之，将大问题分解为多个小问题，将复杂问题分解为多个简单问题

## 3.2 抽象：

更高层次来说，人们处理复杂性有一个通用技术，即抽象。由于不能掌握全部复杂对象，我们选择忽视它的非本质细节，而区处理泛化和理想化了的对象模型。

# 四、重新认识面向对象

为什么要用面向对象的设计？

变化是复用的天敌！面向对象设计最大的优势在于 -- 抵御变化！

## 4.1 理解隔离变化：

从宏观层面来看，面向对象的构建方式更能适应软件的变化，能将变化所带来的影响减为最小。

## 4.2 各司其职

从微观层面来看，面向对象的方式更强调各个类的“责任”
由于需求变化导致的新增类型不应该影响到原来类型的实现——是所谓各负其责

## 4.3 从语言实现层面看，对象封装了代码和数据。

从规格层面讲，对象是一系类可被使用的公共接口
从概念层面讲，对象是某种拥有责任的抽象。

# 五、统一建模语言（Unified Modeling Language，UML

用来设计软件蓝图的可视化建模语言，它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。

以下类图使用 [PlantUML](https://www.planttext.com/) 绘制，更多语法及使用请参考：http://plantuml.com/ 。

## 5.1 类、接口和类图

### 5.1.1 类

类（Class）是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性。
注意：“可见性”表示该属性对类外的元素是否可见，包括公有（Public）、私有（Private）、受保护（Protected）和朋友（Friendly）4 种，在类图中分别用符号+、-、#、~表示。

![](pics\classes-method-property.png)

```
@startuml

title Properties / Methods - Class Diagram


skinparam componentStyle uml2
class Car {
  .. Field Examples ..
- Name: Type { arg1, arg2, argn }
+Name: Type { arg1, arg2, argn }
#Name: Type { arg1, arg2, argn }
~Name: Type { arg1, arg2, argn }

  .. Method Examples ..
-Name(): Type { arg1, arg2, argn }
+Name(): Type { arg1, arg2, argn }
#Name(): Type { arg1, arg2, argn }
~Name(): Type { arg1, arg2, argn }

  .. Static Example ..
+{static} Name(): Type { arg1, arg2, argn }

  .. Abstract Example ..
+{abstract} Name(): Type { arg1, arg2, argn }
}

class Car
ICar ()- Car
ICar2 ()-- Car
Car -() ICar3

@enduml
```

### 5.1.2 接口

接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现。它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作。在 UML 中，接口使用一个带有名称的小圆圈来进行表示。


![img](pics\interfaces.png)

### 5.1.3 类图

类图（Class Diagram）是用来显示系统中的类、接口、协作以及它们之间的静态结构和关系的一种静态模型。

## 5.2 类之间的关系

在软件系统中，类不是孤立存在的，类与类之间存在各种关系。根据类与类之间的耦合度从弱到强排列，UML 中的类图有以下几种关系：**依赖关系**、**关联关系**、**聚合关系**、**组合关系**、**泛化关系**和**实现关系**。其中**泛化和实现的耦合度相等，它们是最强的**。

### 5.2.1 依赖关系

依赖（Dependency）关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。
在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。人与手机的关系图，人通过手机的语音传送方法打电话。

![依赖关系](pics\Dependency.png)

```
@startuml

title Dependency

class Person{
    -String name
    +void call(MobilePhone phone)
}

interface MobilePhone{
    +void transfer()
}

note "public void call(MobilePhone phone) \n \tphone.transfer();//语音传送\n}" as N 
 
Person ..>MobilePhone

Person .. N
@enduml
```

### 5.2.2 关联关系

关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。
关联可以是双向的，也可以是单向的。在 UML 类图中，双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。也可以在关联线的两端标注角色名，代表两种不同的角色。

![关联关系](pics\Association.png)

```
@startuml

title Association

class Teacher{
    -String name
    -List<Student> stus
    +void teaching()
}

class Student{
    -String name
    -List<Teacher> teas
    +void learning()
}

Teacher "n" - "n" Student

@enduml
```

### 5.2.3 聚合关系

聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。
聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。

![聚合关系](pics\Aggregation.png)

```
@startuml

title Aggregation

class Teacher{
    -String name
    +void teaching()
}

class University{
    -List<Teacher> teas
}

University o-- Teacher

@enduml
```

### 5.2.4 组合关系

组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 contains-a 关系。
在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。

![组合关系](pics\Compositions.png)







```
@startuml

title Composition

class Head{
    -Mouth mouth
}

class Mouth{
    +void eat()
}

Head *-- Mouth

@enduml
```

### 5.2.5 泛化关系

泛化（Generalization）关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。
在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类。

![泛化关系](pics\Generalization.png)

```
@startuml

title Generalization

class Person{
    -String name
    -int age
    +void speak()
}

class Student{
    +long studentNo
    +void study()
}

class Teacher{
    -long teacherNo
    +void teaching()
}

Person <|-- Student

Person <|-- Teacher


@enduml
```

### 5.2.6 实现关系

实现（Realization）关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。
在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具。

![实现关系](pics\Realization.png)

```
@startuml

title Realization

interface Vehicle{
    +void move()
}

class Car{
    +void move()
}

class Trunk{
    +void move()
}

Vehicle <|.. Car
Vehicle <|.. Trunk

@enduml
```



# 六、面向对象的设计原则

## 6.1 S.O.L.I.D

| 简写 | 全拼                                | 中文翻译     |
| ---- | ----------------------------------- | ------------ |
| SRP  | The Single Responsibility Principle | 单一责任原则 |
| OCP  | The Open Closed Principle           | 开放封闭原则 |
| LSP  | The Liskov Substitution Principle   | 里氏替换原则 |
| ISP  | The Interface Segregation Principle | 接口分离原则 |
| DIP  | The Dependency Inversion Principle  | 依赖倒置原则 |

### 6.1.1. 单一责任原则

> 修改一个类的原因应该只有一个。

换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。

如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。

### 6.1.2. 开放封闭原则

> 类应该对扩展开放，对修改关闭。

扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。

符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。

### 6.1.3. 里氏替换原则

> 子类对象必须能够替换掉所有父类对象。

继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。

如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。

### 6.1.4. 接口分离原则

> 不应该强迫客户依赖于它们不用的方法。

因此使用多个专门的接口比使用单一的总接口要好。

### 6.1.5. 依赖倒置原则

> 高层模块不应该依赖于低层模块，二者都应该依赖于抽象；
> 抽象不应该依赖于细节，细节应该依赖于抽象。

高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。

依赖于抽象意味着：

- 任何变量都不应该持有一个指向具体类的指针或者引用；
- 任何类都不应该从具体类派生；
- 任何方法都不应该覆写它的任何基类中的已经实现的方法。

## 6.2 其他常见原则

除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。

| 简写 | 全拼                              | 中文翻译     |
| ---- | --------------------------------- | ------------ |
| LOD  | The Law of Demeter                | 迪米特法则   |
| CRP  | The Composite Reuse Principle     | 合成复用原则 |
| CCP  | The Common Closure Principle      | 共同封闭原则 |
| SAP  | The Stable Abstractions Principle | 稳定抽象原则 |
| SDP  | The Stable Dependencies Principle | 稳定依赖原则 |

### 6.2.1.迪米特法则

迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。

### 6.2.2. 合成复用原则

尽量使用对象组合，而不是通过继承来达到复用的目的。

### 6.2.3. 共同封闭原则

一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。

### 6.2.4. 稳定抽象原则

最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。

### 6.2.5. 稳定依赖原则

包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。

# 写在设计模式之前

重构推荐书籍：

重构——改善既有代买的设计

重构与模式（refactoring to patterns)

重构关键技法：

- 静态 --> 动态
- 早绑定--> 晚绑定
- 继承 --> 组合
- 编译时依赖 --> 运行时依赖
- 紧耦合  --> 松耦合

# 七、组件协作

现代软件专业分工之后的第一个结构是”**框架**与**应用程序**的划分”，“组件协作”模式通过**晚期绑定**，来实现框架与应用程序质检的**松耦合**，是二者之间协作时常用模式。

## 典型模式

### 7.1 Template Method (**Behavioral Pattern**)

Motivation

在软件构建过程中，对于某一项任务，它常常有**稳定**的整体操作结构，单各个子步骤却又很多**改变**的需求，或者由于固有的原因（比如框架 与应用之间的关系）而无法和任务的整体结构同时实现。

如何在确定 稳定操作结构的前提下，来灵活应对各个子步骤的**变化**或者**晚期**实现的需求。

Indent

定义一个操作中的算法的骨架 （稳定），而将一些步骤延迟到（变化）到子类中。Template Method 使得子类可以不改变（复用）一个算法的结构即可重定义（override 重写）该算法的某些特定步骤。

Class Diagram

![](pics\TemplateMethod.bmp)

Implementation In Java

冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。

![](pics\TemplateMethodExample.png)

```java
public abstract class CaffeineBeverage {
    void prepareRecipe(){
        boilWater();
        brew();
        pourInCup();
        addCondiments();
    }

    protected abstract void addCondiments();

    private void pourInCup() {
        System.out.println("pourInCup...");
    }

    protected abstract void brew();

    private void boilWater() {
        System.out.println("boilWater...");
    }
}
```

```java
public class Coffee extends CaffeineBeverage {
    @Override
    protected void addCondiments() {
        System.out.println("Coffee addCondiments...");
    }

    @Override
    protected void brew() {
        System.out.println("Coffee brew...");
    }
}
```

```java
public class Tea extends CaffeineBeverage {
    @Override
    protected void addCondiments() {
        System.out.println("Tea addCondiments..");
    }

    @Override
    protected void brew() {
        System.out.println("Tea brew...");

    }
}
```

```java
public class App {
    public static void main(String[] args) {
        CaffeineBeverage tea = new Tea();
        tea.prepareRecipe();
        System.out.println("...");
        CaffeineBeverage coffee = new Coffee();
        coffee.prepareRecipe();
    }
}

```

JDK

- java.util.Collections#sort()
- java.io.InputStream#skip()
- java.io.InputStream#read()
- java.util.AbstractList#indexOf()

Implementation In Python

实现一个横幅生成器。将一段文本发送给一个函数，该函数要生成一个包含该文本的横幅。横幅有多重风格，比如点或虚线围绕文本。横幅生成器有一个默认风格，但应该能够使用我们自己提供的风格。

```python
from cowpy import cow


def dots_style(msg):
    msg = msg.capitalize()
    msg = '.' * 10 + msg + '.' * 10
    return msg;


def admire_style(msg):
    msg = msg.upper()
    return '!'.join(msg);


def cow_style(msg):
    msg = cow.milk_random_cow(msg)
    return msg


def generate_banner(msg, style=dots_style):
    print(' -- start banner --')
    print(style(msg))
    print(' -- end banner -- \n\n')


def main():
    msg = "happy coding"
    [generate_banner(msg, style) for style in (dots_style, admire_style, cow_style)]
```

Summary

1. Template Method 模式 是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。
2. 除了可以灵活应对子步骤的变化外，“不要调用我，让我来调用你“的反响控制结构是Template Method的典型应用。
3. 在具体实现方面，被Template Method调用的方法可以有实现，也可以没有实现（抽象方法），但一般把它们设置为protected方法。



### 7.2 Strategy (**Behavioral Pattern**)

Motivation

在软件的构建过程中，某些对象使用的算法可能多重多样，经常**改变**，如果将这些算法都编码到对象中，将会使对象变得异常复杂，而且有时候支持不使用的算法也是一个性能负担。

如何在运行时根据需要透明的更改对象的算法？将算法与对象本身解耦，从而避免上述问题？

Indent

定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序（稳定）而变化（扩展，子类化）。

Class Diagram

- Strategy 接口定义了一个算法族。
- Context 是使用到该算法族的类。

![](pics\Strategy.bmp)

与状态模式的比较

状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。

状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。

Implementation In Java

以下是一个关税的例子，不同国家的关税计算策略都不一样。

```java
public interface ITaxStrategy {
    void calculate();
}

```

```java
public class CNTax implements ITaxStrategy{
    @Override
    public void calculate() {
        System.out.println("CNTax calculated...");
    }
}

```

```java
public class DETax implements ITaxStrategy {
    @Override
    public void calculate() {
        System.out.println("DETax calculated...");
    }
}
```

```java
public class USTax implements ITaxStrategy{
    @Override
    public void calculate() {
        System.out.println("USTax calculated...");
    }
}
```

```java
public class SaleOrder {
    private ITaxStrategy strategy;

    public SaleOrder(ITaxStrategy strategy) {
        this.strategy = strategy;
    }

    public void changeStrategy(ITaxStrategy strategy) {
        this.strategy = strategy;
    }

    public void calculateTax() {
        if (strategy != null)
            strategy.calculate();
    }
}
```

JDK

- java.util.Comparator#compare()
- javax.servlet.http.HttpServlet
- javax.servlet.Filter#doFilter()

Implementation In Python

实现订单打折策略

```python
class Order():
    def __init__(self, price, discount_strategy=None):
        self.price = price
        self.discount_strategy = discount_strategy

    def price_after_discount(self):
        if self.discount_strategy:
            discount = self.discount_strategy(self)
        else:
            discount = 0;
        return self.price - discount

    def __repr__(self):
        fmt = '<Price: {}, Price after discount: {}>'
        fmt.format(self.price, self.price_after_discount())


def ten_present_discount(order):
    return order.price * 0.10


def on_sale_discount(order):
    return order.price * 0.20 + 20


def main():
    print(Order(100).price_after_discount())

    print(Order(100, discount_strategy=ten_present_discount).price_after_discount())

    print(Order(1000, discount_strategy=on_sale_discount).price_after_discount())


if __name__ == '__main__':
    main()

```

Summary

1. Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在**运行时**方便地根据需要在各个算法质检进行切换。
2. Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式。
3. 如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。（这句话意思就是如果没有 策略实现，那么就可以在全局创建一个单例的对象，大家一起用）

### 7.3 Observer/Event

Motivation

在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系”——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很多好地抵御变化。

使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。

Intent

定义对象间的一种**一对多(**变化)的依赖关系，以便当一个对象（Subject）的状态发生**变化**时，所有依赖于它的对象都得到通知并自动更新。

Class Diagram

• Subject（目标）
— 目标知道它的观察者。可以有任意多个观察者观察同一个目标。
— 提供注册和删除观察者对象的接口。
• Observer（观察者）
— 为那些在目标发生改变时需获得通知的对象定义一个更新接口。
• ConcreteSubject（具体目标）
— 将有关状态存入各 ConcreteObserver 对象。
— 当它的状态发生改变时, 向它的各个观察者发出通知。
• ConcreteObserver（具体观察者）
— 维护一个指向 ConcreteSubject 对象的引用。
— 存储有关状态，这些状态应与目标的状态保持一致。
— 实现 Observer 的更新接口以使自身状态与目标的状态保持一致。

• 当 ConcreteSubject 发生任何可能导致其观察者与其本身状态不一致的改变时，它将通知它的各个观察者。
• 在得到一个具体目标的改变通知后, ConcreteObserver 对象可向目标对象查询信息。ConcreteObserver使用这些信息以使它的状态与目标对象的状态一致。

![](pics\Observer.bmp)

Implementation In Java

```java
public interface Subject {
    void registerObserver(Observer observer);
    void removeObserver(Observer observer);
    void notifyObservers();
}

```

```java
public class WeatherData implements Subject {
    private float temperature;
    private float humidity;
    private float pressure;
    private List<Observer> observers;

    public WeatherData() {
        this.observers = new ArrayList<>();
    }

    @Override
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        int i = observers.indexOf(observer);
        if (i >= 0)
            observers.remove(observer);

    }

    @Override
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(temperature, humidity, pressure);
        }
    }

    private void measurementChanged() {
        notifyObservers();
    }

    public void setMeasurements(float temperature, float humidity, float pressure) {
        this.temperature = temperature;
        this.humidity = humidity;
        this.pressure = pressure;
        measurementChanged();
    }
}
```

```java
public interface Observer {
    void update(float temperature, float humidity, float pressure);
}

```

```java

public class CurrentConditionDisplay implements Observer {
    private float temperature;
    private float humidity;
    private Subject weatherData;

    public CurrentConditionDisplay(Subject weatherData) {
        this.weatherData = weatherData;
        weatherData.registerObserver(this);
    }

    public void display() {
        System.out.println("Current conditions: " + temperature
                + "F degrees and " + humidity + "% humidity");
    }

    @Override
    public void update(float temperature, float humidity, float pressure) {
        this.temperature = temperature;
        this.humidity = humidity;
        display();
    }
}
```

```java

public class ForecastDisplay implements Observer {
    private float temperature;
    private float humidity;
    private Subject weatherData;

    public ForecastDisplay(Subject weatherData) {
        this.weatherData = weatherData;
        weatherData.registerObserver(this);
    }

    public void display() {
        System.out.println("Forecast : " + temperature
                + "F degrees and " + humidity + "% humidity");
    }

    @Override
    public void update(float temperature, float humidity, float pressure) {
        this.temperature = temperature;
        this.humidity = humidity;
        display();
    }
}
```

```java

public class StatisticsDisplay implements Observer {
    private float temperature;
    private float humidity;
    private Subject weatherData;

    public StatisticsDisplay(Subject weatherData) {
        this.weatherData = weatherData;
        weatherData.registerObserver(this);
    }

    public void display() {
        System.out.println("Statistics : " + temperature
                + "F degrees and " + humidity + "% humidity");
    }

    @Override
    public void update(float temperature, float humidity, float pressure) {
        this.temperature = temperature;
        this.humidity = humidity;
        display();
    }
}

```

```java

public class WeatherStation {
    public static void main(String[] args) {
        WeatherData weatherData = new WeatherData();
        CurrentConditionDisplay currentDisplay =
                new CurrentConditionDisplay(weatherData);
        StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);
        ForecastDisplay forecastDisplay = new ForecastDisplay(weatherData);
        weatherData.setMeasurements(80, 65, 30.4f);
        weatherData.setMeasurements(82, 70, 29.2f);
        weatherData.setMeasurements(78, 90, 29.2f);
    }
}

```

JDK

- java.util.EventListener
- javax.servlet.http.HttpSessionBindingListener
- javax.servlet.http.HttpSessionAttributeListener
- javax.faces.event.PhaseListener

Implementation In Python

```python
class Subject(object):
    def __init__(self):
        self._observers = []

    def attach(self, observer):
        if observer not in self._observers:
            self._observers.append(observer)

    def detach(self, observer):
        try:
            if observer in self._observers:
                self._observers.remove(observer)
        except ValueError:
            pass

    def notify(self, modifier=None):
        for observer in self._observers:
            if modifier != observer:
                observer.update(self)


class Data(Subject):
    def __init__(self, name=''):
        Subject.__init__(self)
        self.name = name
        self._data = 0

    @property
    def data(self):
        return self._data

    @data.setter
    def data(self, value):
        self._data = value
        self.notify()


class HexViewer:
    def update(self, subject):
        print(u'HexViewer: Subject %s has data 0x%x' % (subject.name, subject.data))


class DecimalViewer:
    def update(self, subject):
        print(u'DecimalViewer: Subject %s has data 0x%x' % (subject.name, subject.data))


def main():
    data = Data('data1')
    veiwer1 = HexViewer()
    veiwer2 = DecimalViewer()

    data.attach(veiwer1)
    data.attach(veiwer2)

    data.data = 10


if __name__ == '__main__':
    main()
```

Summary

1. 使用面向对象的抽象，Observer模式使得我们可以独立地改变目标和观察者，从而使二者之间的依赖关系达到松耦合。
2. 目标发送通知时，无须指定观察者，通知（可以携带通知信息作为参数）会自动传播。
3. 观察者自己决定是否需要订阅信息，目标对象对此一无所知。
4. Observer模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式一个重要组成部分。

# 八、单一责任

在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。

## 8.1 Decorator (Structural Patterns)

Motivation

在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。

如何使“对象功能的扩展”能够根据需要来动态地实现？同时避免“扩展功能的增多”带来的子类膨胀问题？从而使得任何“功能扩展变化所导致的影响降为最低？

Intent

动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator 模式比生成自来（继承）更为灵活（消除重复代码&减少子类个数）。

Class Diagram

装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component），具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。

![](pics\Decorator.png)

Implementation In Java

设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。

下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。

![](pics\Decorator Demo.jpg)

```java
public abstract class Beverage {
    private String description = "Unknown Beverage";

    public String getDescription(){
        return description;
    }

    public abstract double cost();
}

```

```java
public class DarkRoast extends Beverage{
    @Override
    public String getDescription() {
        return "DarkRoast";
    }

    @Override
    public double cost() {
        return 1.99;
    }
}
```

```java
public class HouseBlend extends Beverage {
    @Override
    public String getDescription() {
        return "HouseBlend";
    }

    @Override
    public double cost() {
        return 2.99;
    }
}
```

```java
public abstract class CondimentDecorator extends Beverage {
    protected Beverage beverage;

    public abstract String getDescription();
}
```

```java
public class Milk extends CondimentDecorator {
    public Milk(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() +  " Milk";
    }

    @Override
    public double cost() {
        return 0.60 + beverage.cost();
    }
}
```

```java
public class Mocha extends CondimentDecorator {

    public Mocha(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + " Mocha";
    }

    @Override
    public double cost() {
        return 0.20 + beverage.cost();
    }
}
```

```java
public class StarbuzzCoffee {
    public static void main(String[] args) {
        Beverage beverage = new DarkRoast();
        beverage = new Milk(beverage);
        beverage = new Mocha(beverage);
        System.out.println(beverage.getDescription());
    }
}
```

JDK

- java.io.BufferedInputStream(InputStream)
- java.io.DataInputStream(InputStream)
- java.io.BufferedOutputStream(OutputStream)
- java.util.zip.ZipOutputStream(OutputStream)
- java.util.Collections#checked[List|Map|Set|SortedSet|SortedMap]()

Implementation In Python

```python
class TextTag(object):
    def __init__(self, text):
        self._text = text

    def render(self):
        return self._text


class BoldWrapper(TextTag):
    """
    wraps a tag in <b>
    """

    def __init__(self, wrapper):
        self._wrapper = wrapper

    def render(self):
        return '<b>{}</b>'.format(self._wrapper.render())


class ItalicWrapper(TextTag):
    """
    wraps a tag in <i>
    """

    def __init__(self, wrapper):
        self._wrapper = wrapper

    def render(self):
        return '<i>{}</i>'.format(self._wrapper.render())


def main():
    hello = TextTag('simple hello')
    render_hello = BoldWrapper(ItalicWrapper(hello))
    print(render_hello.render())


if __name__ == '__main__':
    main()

```

Summary

1. 通过采用组合而非采用继承的手法，Decorator 模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多个子类衍生的问题”
2.  Decorator 类在接口上表现为is-a-Component的继承关系，即Decorator 类继承了Component类所具有的的接口。但在实现上又表现为has-a-Component的组合关系，即Decorator 类又实用了另外一个Component类。
3.  Decorator 模式的目的并非解决“多子类衍生的多继承”问题，Decorator 模式用用的要点在于解决“主体类在多个方向上的扩展功能”——是为“装饰”的含义。

## 8.2 Bridge (Structural Patterns)

Motivation

由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度，乃至多个维度的变化。

如何应对这种“多维度的变化”？如何利用面向对象技术来使得类型可以轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度？

Intent

将抽象部分（业务功能）与实现部分（平台实现）分离，使它们都可以独立地变化。

Class Diagram

- Abstraction：定义抽象类的接口
- Implementor：定义实现类接口

![](pics\Bridge.png)

Implementation In Java

RemoteControl 表示遥控器，指代 Abstraction。

TV 表示电视，指代 Implementor。

桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。

```java
public interface TV {
    void on();

    void off();

    void tuneChannel();
}

```

```java
public class RCA implements TV {
    @Override
    public void on() {
        System.out.println("RCA on...");
    }

    @Override
    public void off() {
        System.out.println("RCA off...");
    }

    @Override
    public void tuneChannel() {
        System.out.println("RCA tuneChannel...");
    }
}
```

```java
public class Sony implements TV {
    @Override
    public void on() {
        System.out.println("Sony on...");
    }

    @Override
    public void off() {
        System.out.println("sony off...");
    }

    @Override
    public void tuneChannel() {
        System.out.println("Sony tuneChannel...");
    }
}
```

```java
public abstract class RemoteControl {
    protected TV tv;

    public RemoteControl(TV tv) {
        this.tv = tv;
    }

    public abstract void on();

    public abstract void off();

    public abstract void tuneChannel();
}
```

```java
public class ConcreteRemote extends RemoteControl {
    public ConcreteRemote(TV tv) {
        super(tv);
    }

    @Override
    public void on() {
        tv.on();
    }

    @Override
    public void off() {
        tv.off();
    }

    @Override
    public void tuneChannel() {
        tv.tuneChannel();
    }
}
```

```java
public class Client {
    public static void main(String[] args) {
        RemoteControl remote = new ConcreteRemote(new RCA());
        remote.on();
        remote.off();
        remote.tuneChannel();
    }
}
```

JDK

- AWT (It provides an abstraction layer which maps onto the native OS the windowing support.)
- JDBC

Implementation In Python

```python
class DrawingAPI1(object):
    def draw_circle(self, x, y, radius):
        print('API1.circle {}:{} radius {} '.format(x, y, radius))


class DrawingAPI2(object):
    def draw_circle(self, x, y, radius):
        print('API2.circle {}:{} radius {} '.format(x, y, radius))


class CircleShape(object):
    def __init__(self, x, y, radius, draw_api):
        self._x = x
        self._y = y
        self._radius = radius
        self._draw_api = draw_api

    def draw(self):
        self._draw_api.draw_circle(self._x, self._y, self._radius)

    def scale(self, pct):
        self._radius *= pct


def main():
    shapes = (CircleShape(1, 2, 3, DrawingAPI1()), CircleShape(4, 5, 6, DrawingAPI2()))

    for shape in shapes:
        shape.scale(2.5)
        shape.draw()


if __name__ == '__main__':
    main()

```

Summary

1. Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自维度的变化，即“子类化”它们。
2. Bridge模式有时候类似于多继承 ( C++ ) 方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原因），复用性太差。
3. Bridge模式的应用一般在“两个非常强的变化维度”，有时一个类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。

# 九、对象创建

通过“对象创建”模式绕开new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的**稳定**。它是接口抽象之后的第一步工作。

## 9.1 Factory Method (Creational Pattern)

Motivation

在软件系统中，经常面临着创建对象的工作；由于需求的变化，需要创建的对象的具体类型经常变化。

如何应对这种变化？如何绕开常规的对象创建方法（new），提供一种“封装机制”来避免客户程序和这种“具体对象创建工作”的紧耦合？

Intent

定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化延迟（目的：解耦，手段：接口）到子类。

Class Diagram

Creator有一个 AnOperation() 方法，这个方法需要用到一个产品对象，这个产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。

![](pics\Factory Method.png)

Implementation In Java

一个披萨店做披萨的例子，纽约Picasa店做纽约的披萨，芝加哥披萨店做芝加哥的披萨。

```java
public abstract class Pizza {
    String name;

    void prepare() {
        System.out.println("Preparing " + name);
    }

    public void bake() {
        System.out.println("bake...");
    }

    public void cut() {
        System.out.println("cut...");
    }

    public void box() {
        System.out.println("box...");
    }

    public String getName() {
        return this.name;
    }
}
```

```java
public class NYStyleCheesePizza extends Pizza {
    public NYStyleCheesePizza() {
        name = "NYStyleCheesePizza";
    }
}
```

```java
public class ChicagoStyleCheesePizza extends Pizza {
    public ChicagoStyleCheesePizza() {
        name = "ChicagoStyleCheesePizza";
    }
}
```

```java
public abstract class PizzaStore {
    abstract Pizza createPizza();

    void orderPizza(){
        Pizza pizza = createPizza();
        //do order pizza
    }
}
```

```java
public class NYStyleCheesePizzaStore extends PizzaStore{
    @Override
    public Pizza createPizza() {
        return new NYStyleCheesePizza();
    }
}
```

```java
public class ChicagoStyleCheesePizzaStore extends PizzaStore {
    @Override
    Pizza createPizza() {
        return new ChicagoStyleCheesePizza();
    }
}
```

JDK

- java.lang.Proxy#newProxyInstance()
- java.lang.Object#toString()
- java.lang.Class#newInstance()
- java.lang.reflect.Array#newInstance()
- java.lang.reflect.Constructor#newInstance()
- java.lang.Boolean#valueOf(String)
- java.lang.Class#forName()

Implementation In Python

python实现一个简单工厂模式

```python
class GreekLocalizer(object):
    """A simple localizer a la gettext"""

    def __init__(self):
        self.translations = {"dog": "σκύλος", "cat": "γάτα"}

    def localize(self, msg):
        """We'll punt if we don't have a translation"""
        return self.translations.get(msg, msg)


class EnglishLocalizer(object):
    """Simply echoes the message"""

    def localize(self, msg):
        return msg


def get_localizer(language="English"):
    """Factory"""
    localizers = {
        "English": EnglishLocalizer,
        "Greek": GreekLocalizer,
    }
    return localizers[language]()

def main():
    e, g = get_localizer(language="English"), get_localizer(language="Greek")
    for msg in "dog parrot cat bear".split():
        print(e.localize(msg), g.localize(msg))
        
if __name__ == '__main__':
    main()
```

Summary

1. Factory Method模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体的类型，紧耦合关系（new）会导致软件的脆弱。
2. Factory Method模式通过面向对象的手法，将所要创建的具体对象工作延迟的子类，从而实现一种扩展（而非改变）的策略，较好地解决了这种耦合关系。
3. Factory Method模式解决“单个对象”的需求变化。缺点在于要求创建方法/参数相同。

## 9.2 Abstract Factory (Creational Pattern)

Motivation

在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时，由于需求的变化，往往存在更多系列对象的创建工作。

如何应对这种变化？如何绕过常规的对象创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建的工作”的紧耦合？

Intent

提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们的具体的类。

Class Diagram

抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。

抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。

至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。

从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承

![](pics\Abstract Factory.png)

Implementation In Java

披萨的例子，披萨由多种原料组成，纽约和芝加哥各自生产各自原料。

```java
public interface Dough {
}
```

```java
public class ChicagoDough implements Dough {
}
```

```java
public class NYDough implements Dough {
}
```

```java
public interface Sauce {
}
```

```java
public class ChicagoSauce implements Sauce{
}
```

```java
public class NYSauce implements Sauce{
}
```

```java
public interface PizzaIngredientFactory {
    Dough createDough();

    Sauce createSauce();
}
```

```java
public class ChicagoPizzaIngredientFactory implements PizzaIngredientFactory {

    @Override
    public Dough createDough() {
        System.out.println("Chicago dough factory....");
        return new ChicagoDough();
    }

    @Override
    public Sauce createSauce() {
        System.out.println("chicago sauce factory....");
        return new ChicagoSauce();
    }
}
```

```java
public class NYPizzaIngredientFactory implements PizzaIngredientFactory {

    @Override
    public Dough createDough() {
        System.out.println("NY dough factory....");
        return new NYDough();
    }

    @Override
    public Sauce createSauce() {
        System.out.println("NY Sauce factory....");
        return new NYSauce();
    }
}
```

```java
public class Pizza {
    String name;
    PizzaIngredientFactory factory;

    public Pizza(String name, PizzaIngredientFactory factory) {
        this.name = name;
        this.factory = factory;
    }

    void prepare() {
        factory.createDough();
        factory.createSauce();
    }

    public static void main(String[] args) {
        Pizza p = new Pizza("Chicago",new ChicagoPizzaIngredientFactory());
        p.prepare();
    }

}
```

JDK

- java.util.Calendar#getInstance()
- java.util.Arrays#asList()
- java.util.ResourceBundle#getBundle()
- java.sql.DriverManager#getConnection()
- java.sql.Connection#createStatement()
- java.sql.Statement#executeQuery()
- java.text.NumberFormat#getInstance()
- javax.xml.transform.TransformerFactory#newInstance()



Implementation In Python

```python
import random


class PetShop(object):
    def __init__(self, animal_factory):
        self.pet_factory = animal_factory

    def show_pet(self):
        pet = self.pet_factory()
        print("we hava lovely {}".format(pet))
        print("It says {}".format(pet.speak()))


class Dog(object):
    def speak(self):
        return "woof"

    def __str__(self):
        return "Dog"


class Cat(object):
    def speak(self):
        return "meow"

    def __str__(self):
        return "Cat"


def random_animal():
    return random.choice([Dog, Cat])


def main():
    cat_shop = PetShop(Cat)
    cat_shop.show_pet()
    print("")

    random_shop = PetShop(random_animal())
    random_shop.show_pet()
    print("")


if __name__ == '__main__':
    main()
```

Summary

1. 如果没有应对“多锡类对象构建”的需求变化，则没有必要使用Abstract Factory 模式，这时候使用简单的工厂完全可以。
2. “系列对象”指的是在某一特定系列下的对象之间有相互依赖、或作用的关系。不同系列的对象之间不能相互依赖。
3. Abstract Factory模式主要在于应对“新系列”的需求变动。其缺点在于难以应对“新对象”的需求变动。

## 9.3 Prototype (Creational Pattern)

注：原型模式是工厂方法的一种变种形式

Motivation

在软件系统中，经常面临着“某些结构复杂的对象”的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是他们却拥有比较稳定一致的接口。

如何应对这种变化？如何向“客户程序（使用这些对象的程序）“隔离出”这些易变的对象“，从而使得”依赖这些易变的客户程序“不随着需求改变而改变。

Intent

使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。

Class Diagram



![](pics\Prototype.png)

Implementation In Java

```java
public abstract class Prototype {
    abstract Prototype myClone();
}	
```

```java
public class ConcretePrototype extends Prototype {
    private String filed;

    public ConcretePrototype(String filed) {
        this.filed = filed;
    }

    @Override
    Prototype myClone() {
        return new ConcretePrototype(filed);
    }

    @Override
    public String toString() {
        return filed;
    }
}
```

```java
public class App {

    public static void main(String[] args) {
        Prototype prototype = new ConcretePrototype("filed");
        Prototype clone = prototype.myClone();
        System.out.println(clone);
    }
}
```



JDK

- java.lang.Object#clone()
- java.lang.Cloneable

Implementation In Python

```python
class Prototype(object):
    value = "default"

    def clone(self, **attrs):
        obj = self.__class__()
        obj.__dict__.update(attrs)
        return obj


class PrototypeDispatcher(object):
    def __init__(self):
        self._objects = {}

    def get_objects(self):
        return self._objects

    def register_object(self, name, obj):
        self._objects[name] = obj

    def unregister_object(self, name):
        del self._objects[name]


def main():
    prototype_dispatcher = PrototypeDispatcher();
    prototype = Prototype()

    d = prototype.clone();
    a = prototype.clone(value="a-value", category="a")
    b = prototype.clone(value="b-value", category="b")

    prototype_dispatcher.register_object("objecta", a)
    prototype_dispatcher.register_object("objectb", b)
    prototype_dispatcher.register_object("default", d)

    print([{n: p.value} for n, p in prototype_dispatcher.get_objects().items()])


if __name__ == '__main__':
    main()

```

Summary

1. Prototype模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些“易变类”拥有“稳定的接口”
2. Prototype 模式对于“如何创建易变类的实体对象”采用“原型克隆”的方法来做，它使得我们可以非常灵活的动态创建“拥有某些稳定接口”的新对象——所需工作仅仅是注册一个新类的对象（即原型），然后在任何需要的地方Clone。
3. Prototype模式中Clone方法可以利用某些框架中的序列化来实现深拷贝。

## 9.4 Builder (Creational Pattern)

Motivation

在软件系统中，有时候面临着“一个复杂的对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。

如何应对这种变化？如何提供一个“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求而改变而改变？

Intent

将一个复杂对象的构建与其表示相分离，使得同样的构建过程（稳定）可以创建不同的表示（变化）。

Class Diagram

![](pics\Builder.png)

Implementation In Java

工程师建造房子的例子

```java
public interface HousePlan {
    void setBasement(String basement);

    void setStructure(String structure);

    void setRoof(String roof);

    void setInterior(String interior);
}
```

```java
public class House implements HousePlan {
    private String basement;
    private String structure;
    private String roof;
    private String interior;

    @Override
    public void setBasement(String basement) {
        this.basement = basement;
    }

    @Override
    public void setStructure(String structure) {
        this.structure = structure;
    }

    @Override
    public void setRoof(String roof) {
        this.roof = roof;
    }

    @Override
    public void setInterior(String interior) {
        this.interior = interior;
    }

    @Override
    public String toString() {
        return "House{" +
                "basement='" + basement + '\'' +
                ", structure='" + structure + '\'' +
                ", roof='" + roof + '\'' +
                ", interior='" + interior + '\'' +
                '}';
    }
}
```

```java
public interface HouseBuilder {
    void buildBasement();

    void buildStructure();

    void buildRoof();

    void buildInterior();

    House getHouse();
}
```

```java

public class IglooHouseBuilder implements HouseBuilder {
    private House house;

    public IglooHouseBuilder() {
        this.house = new House();
    }

    @Override
    public void buildBasement() {
        this.house.setBasement("Ice Bars");
    }

    @Override
    public void buildStructure() {
        this.house.setStructure("Ice Block");
    }

    @Override
    public void buildRoof() {
        this.house.setRoof("Ice Carvings");
    }

    @Override
    public void buildInterior() {
        this.house.setInterior("Ice Dome");
    }

    public House getHouse() {
        return this.house;
    }
}
```

```java

public class CivilEngineer {
    private HouseBuilder houseBuilder;

    public CivilEngineer(HouseBuilder houseBuilder) {
        this.houseBuilder = houseBuilder;
    }

    public House getHouse() {
        return this.houseBuilder.getHouse();
    }

    public void constructHouse() {
        this.houseBuilder.buildBasement();
        this.houseBuilder.buildStructure();
        this.houseBuilder.buildRoof();
        this.houseBuilder.buildInterior();
    }
}
```

```java
public class Builder {
    public static void main(String[] args) {
        HouseBuilder builder = new IglooHouseBuilder();
        CivilEngineer engineer = new CivilEngineer(builder);

        engineer.constructHouse();

        System.out.println(engineer.getHouse());
    }
}
```

JDK

- java.lang.StringBuilder#append()
- java.lang.StringBuffer#append()
- java.sql.PreparedStatement
- javax.swing.GroupLayout.Group#addComponent()

Implementation In Python

```python
class ComplexBuilding(object):
    def __repr__(self):
        return 'Floor:{0.floor} | Size : {0.size}'.format(self)


class ComplexHouse(ComplexBuilding):
    def build_floor(self):
        self.floor = 'One'

    def build_size(self):
        self.size = 'Big and Fancy'


def construct_buildings(cls):
    building = cls()
    building.build_floor()
    building.build_size()
    return building


if __name__ == '__main__':
    complexHouse = construct_buildings(ComplexHouse)
    print(complexHouse)

```

Summary

1. Builder模式主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。
2. 变化点在哪里，分装哪里——Builder模式主要在于应对“复杂对象各个部分”的频繁需求变动。其缺点在于难以应对“分步骤构建算法”的需求变动。
3. 在Builder模式中，要注意不同语言中构造器内调用函数的差别（C++ vs C#）。

# 十、对象性能

面向对象很好地解决了“抽象”问题，但是必不可免地要付出一定的代价。对于通常情况来讲，面向对象的成本都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理。

## 10.1 Singleton (Structural Pattern)

Motivation

在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能确保它们的逻辑的正确性、以及良好的效率。

如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？

这应该是类设计者的责任，而不是使用者的责任。

Intent

保证一个类仅有一个实例，并提供一个该实例的全局访问点。

Class Diagram

![](pics\Singleton.png)

Implementation In Java

**Ⅰ 懒汉式-线程不安全**

以下实现中，私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。

这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 `if (uniqueInstance == null)` ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 `uniqueInstance = new Singleton();` 语句，这将导致实例化多次 uniqueInstance。

```java
public class Singleton {

    private static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            uniqueInstance = new Singleton();
        }
        return uniqueInstance;
    }
}
```

**Ⅱ 饿汉式-线程安全**

线程不安全问题主要是由于 uniqueInstance 被实例化多次，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全问题。

但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。

```java
private static Singleton uniqueInstance = new Singleton();
```

**Ⅲ 懒汉式-线程安全**

只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次 uniqueInstance。

但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 uniqueInstance 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。

```java
public static synchronized Singleton getUniqueInstance() {
    if (uniqueInstance == null) {
        uniqueInstance = new Singleton();
    }
    return uniqueInstance;
}
```

**Ⅳ 双重校验锁-线程安全**

uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。

双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。

```java
public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```

考虑下面的实现，也就是只使用了一个 if 语句。在 uniqueInstance == null 的情况下，如果两个线程都执行了 if 语句，那么两个线程都会进入 if 语句块内。虽然在 if 语句块内有加锁操作，但是两个线程都会执行 `uniqueInstance = new Singleton();` 这条语句，只是先后的问题，那么就会进行两次实例化。因此必须使用双重校验锁，也就是需要使用两个 if 语句：第一个 if 语句用来避免 uniqueInstance 已经被实例化之后的加锁操作，而第二个 if 语句进行了加锁，所以只能有一个线程进入，就不会出现 uniqueInstance == null 时两个线程同时进行实例化操作。

```java
if (uniqueInstance == null) {
    synchronized (Singleton.class) {
        uniqueInstance = new Singleton();
    }
}
```

uniqueInstance 采用 volatile 关键字修饰也是很有必要的， `uniqueInstance = new Singleton();` 这段代码其实是分为三步执行：

1. 为 uniqueInstance 分配内存空间
2. 初始化 uniqueInstance
3. 将 uniqueInstance 指向分配的内存地址

但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1>3>2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。

使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。

**Ⅴ 静态内部类实现**

当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 `getUniqueInstance()` 方法从而触发 `SingletonHolder.INSTANCE` 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。

这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。

```java
public class Singleton {

    private Singleton() {
    }

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getUniqueInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

**Ⅵ 枚举实现**

```java
public enum Singleton {

    INSTANCE;

    private String objName;


    public String getObjName() {
        return objName;
    }


    public void setObjName(String objName) {
        this.objName = objName;
    }


    public static void main(String[] args) {

        // 单例测试
        Singleton firstSingleton = Singleton.INSTANCE;
        firstSingleton.setObjName("firstName");
        System.out.println(firstSingleton.getObjName());
        Singleton secondSingleton = Singleton.INSTANCE;
        secondSingleton.setObjName("secondName");
        System.out.println(firstSingleton.getObjName());
        System.out.println(secondSingleton.getObjName());

        // 反射获取实例测试
        try {
            Singleton[] enumConstants = Singleton.class.getEnumConstants();
            for (Singleton enumConstant : enumConstants) {
                System.out.println(enumConstant.getObjName());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
```

该实现可以防止反射攻击。在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。

该实现在多次序列化和序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。

JDK

- java.lang.Runtime#getRuntime()
- java.awt.Toolkit#getDefaultToolkit()
- java.awt.GraphicsEnvironment#getLocalGraphicsEnvironment()
- java.awt.Desktop#getDesktop()

Summary

1. Singleton模式中的实例构造器可以设置为protected以允许子类派生。
2. Singleton模式一般不要支持拷贝构造函数clone接口，因为这有可能导致多个对象实例，与Singleton模式的初衷违背。
3. 如何实现多线程环境下安全的Singleton？注意对双检查锁的正确实现。

## 10.2 FlyWeight  (Creational Pattern)

Motivation

在软件系统采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行时代价——主要指内存需求方面的代价。

如何在避免大量细粒度的对象问题的同时，让外部客户程序仍然能够透明地使用面向对象的方式来进行操作？

Intent

运用共享技术有效地支持大量细粒度的对象。

Class Diagram

![](pics\FlyWeight.png)

Implementation In Java

```java
public interface Flyweight {
    void operation(String extrinsicState);
}
```

```java
public class ConcreteFlyWeight implements Flyweight {
    private String intrinsicState;

    public ConcreteFlyWeight(String intrinsicState) {
        this.intrinsicState = intrinsicState;
    }

    @Override
    public void operation(String extrinsicState) {
        System.out.println("address: " + System.identityHashCode(extrinsicState));
        System.out.println("intrinsicState: " + intrinsicState);
        System.out.println("extrinsicState: " + extrinsicState);
    }
}
```

```java
public class FlyWeightFactory {
    private ConcurrentHashMap<String, Flyweight> map = new ConcurrentHashMap<>();

    public Flyweight getFlyweight(String intrinsicState) {
        Flyweight flyweight;
        if (!map.containsKey(intrinsicState)) {
            map.put(intrinsicState, new ConcreteFlyWeight(intrinsicState));
        }
        return map.get(intrinsicState);
    }
}
```



JDK

- java.lang.Integer#valueOf(int)
- java.lang.Boolean#valueOf(boolean)
- java.lang.Byte#valueOf(byte)
- java.lang.Character#valueOf(char)

Implementation In Python

```java
import weakref


class Car(object):
    _pool = weakref.WeakValueDictionary()

    def __new__(cls, value, suit):
        obj = cls._pool.get(value + suit)
        if obj is None:
            obj = object.__new__(Car)
            cls._pool[value + suit] = obj
            obj.value, obj.suit = value, suit
        return obj

    def __repr__(self):
        return "Car: %s %s" % (self.value, self.suit)


def main():
    car1 = Car('9', 'a')
    car2 = Car('9', 'a')

    print(car1 == car2)


if __name__ == '__main__':
    main()
```

Summary

1. 面向对象很好地解决了抽象性的问题，但是作为一个运行在机器中的程序实体，我们需要考虑独享的代价问题。FlyWeight主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题。
2. FlayWeight采用对象共享的做法来减低系统中对象的个数，从而降低细粒度对象给系统的内存压力。在具体实现方面，要注意对象状态的处理。
3. 对象的数量太大从而导致对象内存开销加大——什么样的数量才算大？这需要我们仔细的根据具体应用情况进行评估，而不能凭空臆断。

# 十一、接口隔离

在组件构建构成中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的解决方案。

## 11.1 Facade (Structural Pattern)

Motivation

![](pics\Facade Demo.png)

上图A方案的问题在于组件的客户和组件中各种复杂的子系统有了过多的耦合，随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。

如何简化外部客户程序和系统间的交互接口？如何将外部客户程序的演化和内部子系统的变化质检的依赖相互解耦？

Intent

为子系统中的一组接口提供一个一致（稳定）的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用（复用）。

Class Diagram

![](pics\Facade.png)

Implementation In Java

酒店服务员相当于facade，客户要向他要各种菜单。

```java
public interface Hotel {
    String getMenus();
}
```

```java
public class NonVegRestaurant implements Hotel {
    @Override
    public String getMenus() {
        return "NonVegMenu";
    }
}
```

```java
public class VegNonBothRestaurant implements Hotel{
    @Override
    public String getMenus() {
        return "Both";
    }
}
```

```java
public class VegRestaurant implements Hotel {
    @Override
    public String getMenus() {
        return "VegMenu";
    }
}

```

```java
public class HotelKeeper {
    private Hotel vegrestaurant;
    private Hotel vegnonbothrestaurant;
    private Hotel nonvegrestaurant;

    public HotelKeeper() {
        this.vegrestaurant = new VegRestaurant();
        this.vegnonbothrestaurant = new VegNonBothRestaurant();
        this.nonvegrestaurant = new NonVegRestaurant();
    }

    public String getVegMenu() {
        return vegrestaurant.getMenus();
    }

    public String getNonVegMenu() {
        return nonvegrestaurant.getMenus();
    }

    public String getVegNonMenu() {
        return vegnonbothrestaurant.getMenus();
    }
}
```

```java
public class Client {
    public static void main(String[] args) {
        HotelKeeper keeper = new HotelKeeper();
        String vegMenu = keeper.getVegMenu();
        String nonVegMenu = keeper.getNonVegMenu();
        String both = keeper.getVegNonMenu();
    }
}
```

JDK

- java.lang.Class
- javax.faces.webapp.FacesServlet

Implementation In Python

```python
class CPU(object):
    def freeze(self):
        print("Freeze processor")

    def jump(self, position):
        print("Jumping to ", position)

    def execute(self):
        print("Executing...")


class Memory(object):
    def load(self, position, data):
        print("Loading from {0} data : {1}".format(position, data))


class SolidStateDrive(object):
    def read(self, lba, size):
        return "Some data from sector {0} with size: {1}".format(lba, size)


class ComputerFacade(object):
    def __init__(self):
        self.cpu = CPU()
        self.memory = Memory()
        self.ssd = SolidStateDrive()

    def start(self):
        self.cpu.freeze()
        self.memory.load("0x00", self.ssd.read("100", "1024"))
        self.cpu.jump("0x00")
        self.cpu.execute()


if __name__ == '__main__':
    facade = ComputerFacade()
    facade.start()

```

Summary

1. 从客户程序角度来看，Facade模式简化了整个组件系统的接口，对于组件内部与外部客户程序来说，达到了一种“解耦”的效果——内部子系统的任何变化不会影响到Facade接口的变化。
2. Facade设计模式更注重从框架层次去看整个系统，而不是单个类的层次。Facade很多时候更是一种框架设计模式
3. Facade设计模式并非一个集装箱，可以任意地放进任何多个对象。Facade模式中组件的内部应该是“相互耦合关系比较大的一系列组件”，而不是一个简单的功能集合。

## 11.2 Proxy (Structural Pattern)

Motivation

在面向对象系统中，有些对象由于某种原因（比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等），直接访问会给使用者、或者系统结构带来很多麻烦。

如何在不失去透明操作对象的同时来管理/控制这些对象的复杂性？增加一层间接层是软件开发中常见的解决方式。

Intent

为其他对象提供一种代理以控制（隔离，使用接口）对这个对象的访问。

Class Diagram

![](pics\Proxy.png)

Implementation In Java

```java
public interface Internet {
    void connectTo(String serverhost) throws Exception;
}
```

```java
public class RealInternet implements Internet {
    @Override
    public void connectTo(String serverhost) throws Exception {
        System.out.println("connect to " + serverhost);
    }
}
```

```java
public class ProxyInternet implements Internet {
    private Internet realInternet = new RealInternet();
    private static List<String> bannedSites;

    static {
        bannedSites = new ArrayList<>();
        bannedSites.add("abc.com");
        bannedSites.add("def.com");
        bannedSites.add("ijk.com");
        bannedSites.add("lnm.com");
    }

    @Override
    public void connectTo(String serverhost) throws Exception {
        if (!bannedSites.contains(serverhost.toLowerCase())) {
            throw new Exception("Access denied!");
        } else {
            realInternet.connectTo(serverhost);
        }
    }
}
```

```java
public class Client {
    public static void main(String[] args) {
        Internet internet = new ProxyInternet();

        try {
            internet.connectTo("abc.com");
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }

    }
}
```

JDK

- java.lang.reflect.Proxy
- RMI

Implementation In Python

```python
import time


class SalesManager:
    def talk(self):
        print("Sales Manager ready to talk")


class Proxy:
    def __init__(self):
        self.busy = 'No'
        self.sales = None

    def talk(self):
        print("Proxy checking for Sales Manager availability")
        if self.busy == 'No':
            self.sales = SalesManager()
            time.sleep(0.1)
            self.sales.talk()
        else:
            time.sleep(0.1)
            print("Sales Manager is busy")


class NoTalkProxy(Proxy):
    def talk(self):
        print("Proxy checking for Sales Manager availability")
        time.sleep(0.1)
        print("This Sales Manager will not talk to you", "whether he/she is busy or not")


if __name__ == '__main__':
    p = Proxy()
    p.talk()
    p.busy = 'Yes'
    p.talk()
    p = NoTalkProxy()
    p.talk()
    p.busy = 'Yes'
    p.talk()
```

Summary

1. “增加一层间接层”是软件系统中对许多复杂问题的一种常见解决方法。在面向对象系统中，直接使用某些对象会带来很多问题，作为间接层的proxy独享便是解决这一问题的常用手段。
2. 具体proxy设计模式的实现方法、实现粒度都相差很大，有些可能对单个对象做细粒度的控制，如copy-on-write技术，有些可能对组件模块提供抽象代理层，在架构层次对对象做proxy。
3. proxy并不一定要求保持接口完整的一致性，只要能够实现间接控制，有时候损失一些透明性是可以接收的。



## 11.3 Adapter (Structural Pattern)

Motivation

在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”存放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的。

如何应对这种“迁移变化”？如何既能利用现有对象的良好表现，同时又能满足新的应用环境所要求的接口？

Intent

将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容儿不能在一起工作的那些类可以一起工作。

Class Diagram

1、 被适配类有接口，可以实现接口完成适配（不推荐，多继承带来的坏处大于好处）

![](pics\Adapter——implement.png)

2、被适配类使用组合方式完成适配

![](pics\Adapter——Composite.png)

Implementation In Java

```java
public interface Bird {
    void fly();
    void makeSound();
}
```

```java
public class Sparrow implements Bird {
    @Override
    public void fly() {
        System.out.println("Sparrow fly...");
    }

    @Override
    public void makeSound() {
        System.out.println("Sparrrow makeSound...");
    }
}
```

```java
public interface ToyDuck {
    void squeak();
}
```

```java
public class PlasticToyDuck implements ToyDuck {
    @Override
    public void squeak() {
        System.out.println("PlasticToyDuck squeak...");
    }
}
```

```java
public class BirdAdapter implements ToyDuck {
    Bird bird;

    public BirdAdapter(Bird bird) {
        this.bird = bird;
    }

    @Override
    public void squeak() {
        bird.makeSound();
    }
}
```

```java
public class App {
    public static void main(String[] args) {
        Sparrow sparrow = new Sparrow();
        PlasticToyDuck duck = new PlasticToyDuck();

        BirdAdapter adapter = new BirdAdapter(sparrow);
        System.out.println("Sparrow....");
        sparrow.fly();
        sparrow.makeSound();

        System.out.println("PlasticToyDuck...");
        duck.squeak();

        System.out.println("BirdAdapter....");
        adapter.squeak();
    }
}
```



JDK

- java.util.Arrays#asList()
- javax.swing.JTable(TableModel)
- java.io.InputStreamReader(InputStream)
- java.io.OutputStreamWriter(OutputStream)
- javax.xml.bind.annotation.adapters.XmlAdapter#marshal()
- javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal()

Implementation In Python

```python
class Dog(object):
    def __init__(self):
        self.name = "Dog"

    def bark(self):
        return "Woof!"


class Adapter(object):
    def __init__(self, obj, **adapted_method):
        self.obj = obj
        self.__dict__.update(adapted_method)

    def __getattr__(self, attr):
        return getattr(self.obj, attr)

    def original_dict(self):
        return self.obj.__dict__


def main():
    dog = Dog()
    print(dog.__dict__)
    adapter = Adapter(dog, make_noise=dog.bark)
    print(adapter.original_dict())
    print(adapter.__dict__)
    print(adapter.__dict__['obj'], adapter.__dict__['make_noise'])


if __name__ == '__main__':
    main()

```

Summary

1. Adapter模式主要应用月“希望复用一些现存的类”，但是接口又与复用环境要求不一致的情况，在遗留代码复用、类库迁移等方面非常有用。
2. GOF 23 定义了两种Adapter模式的实现结构：对象适配器和类适配器。但是类适配器采用“多继承”的实现方式，一般不推荐使用。对象适配器采用“对象组合”的方式，更符合松耦合的精神。
3. Adapter模式可以实现的非常灵活，不必拘泥于GOF 23中定义的两种结构。例如，完全可以将Adapter模式中的“实现对象“作为先的接口方法参数，来达到适配的目的。

## 11.4 Mediator  (**Behavioral Pattern**)

Motivation

在软件构建过程中，经常会出现多个对象互相关联交互的情况，对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化。

这种情况下，我们可使用一个“中介对象”来管理对象间的关联关系，避免互相交互的紧耦合引用关系，从而更好地抵御变化。

Intent

用一个中介对象来封装（封装变化）一系列的对象交互。中介者使各对象不需要显示的相互引用（编译时依赖-> 运行时依赖），从而使其耦合松散（管理变化），而且可以独立第改变它们之间的交互。

Class Diagram

![](pics\Mediator.png)

下图表示更普通的情况，抽离一个中介者，跟所有对象都双向依赖，可以建立某种通知机制，来表示各个组件之间的通知顺序。

![](pics\Mediator-Common.png)

Implementation In Java

```java
public interface IATCMediator {
    void registerRunway(Runway runway);

    void registerFlight(Flight flight);

    boolean isLandingOk();

    void setLandingStatus(boolean status);
}
```

```java
public class ATCMediator implements IATCMediator {
    private Flight flight;
    private Runway runway;
    private boolean land;

    @Override
    public void registerRunway(Runway runway) {
        this.runway = runway;
    }

    @Override
    public void registerFlight(Flight flight) {
        this.flight = flight;
    }

    @Override
    public boolean isLandingOk() {
        return land;
    }

    @Override
    public void setLandingStatus(boolean status) {
        this.land = status;
    }
}
```

```java
public interface Command {
    void land();
}
```

```java
public class Flight implements Command{
    private IATCMediator atcMediator;

    public Flight(IATCMediator atcMediator) {
        this.atcMediator = atcMediator;
    }

    @Override
    public void land() {
        if(atcMediator.isLandingOk()){
            System.out.println("successful landed..");
            atcMediator.setLandingStatus(true);
        }else{
            System.out.println("waitring for landing...");
        }
    }
    public void getReady(){
        System.out.println("ready to landing...");
    }
}
```

```java
public class Runway implements Command{
    private IATCMediator atcMediator;

    public Runway(IATCMediator atcMediator) {
        this.atcMediator = atcMediator;
        this.atcMediator.setLandingStatus(true);
    }

    @Override
    public void land() {
        System.out.println("Landing permission granted.");
        this.atcMediator.setLandingStatus(true);
    }
}
```

```java
public class App {
    public static void main(String[] args) {
        IATCMediator atcMediator = new ATCMediator();
        Flight flight = new Flight(atcMediator);
        Runway runway = new Runway(atcMediator);

        atcMediator.registerFlight(flight);
        atcMediator.registerRunway(runway);

        flight.getReady();
        runway.land();
        flight.land();
    }
}
```

JDK

- java.util.Timer
- java.util.concurrent.Executor#execute()
- java.util.concurrent.ExecutorService#submit()
- java.lang.reflect.Method#invoke()

Implementation In Python

```python
class ChatRoom(object):
    """mediator """

    def display_message(self, user, message):
        print("[{} says]: {}".format(user, message))


class User(object):
    def __init__(self, name):
        self.name = name
        self.chat_room = ChatRoom()

    def say(self, message):
        self.chat_room.display_message(self, message)

    def __str__(self):
        return self.name


def main():
    zs = User("zhangsan")
    ls = User("lisi")
    ww = User("wangwu")

    zs.say("hello")
    ls.say("nihao")
    ww.say("886")


if __name__ == '__main__':
    main()
```

Summary

1. 将多个对象之间的复杂关联关系解耦，Mediator模式将多个对象间的控制逻辑进行集中管理，便“多个对象互相关联”为“多个对象和一个中介者关联”，简化了系统的维护，抵御了可能的变化。
2. 随着控制扩机的复杂化，Mediator具体对象的实现可能相当复杂。这时候可以对Mediator对象进行分解处理。
3. Facade模式是解耦系统间（单向）的对象关联关系；Mediator模式是解耦系统内各个对象之间（双向）的关联关系。



# 十二、状态变化

在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效管理？同时又维持高层模块的稳定？“状态变化”模式为这一问题提供了一种解决方案。

## 12.1 Memento  (**Behavioral Pattern**)

Motivation

在软件构建构成中，某些对象的状态在转换过程中，可能由于某种需要，要求程序能够回溯到对象之前某个点时的状态。如果使用一些公有接口来让其他对象得到对象的状态，便会暴露对象的细节实现。

如何实现对象状态的良好保存于恢复？但同时又不会因此而破坏对象本身的封装性。

Intent

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先的状态。

Class Diagram

![](pics\Memento.png)

Implementation In Java

```java
public class Life {
    private String time;

    public void set(String time){
        System.out.println("Setting time to " + time);
        this.time = time;
    }

    public Memento saveToMemento(){
        System.out.println("Saving time to Memento");
        return new Memento(time);
    }

    public void restoreFromMemento(Memento m){
        time = m.getStoredTime();
        System.out.println("Time restored from Memento: " + time);
    }

    public static class Memento{
        private final String time;

        public Memento(String time) {
            this.time = time;
        }

        public String  getStoredTime(){
            return time;
        }
    }
}
```

```java
public class Client {
    public static  void main(String[] args) {
        List savedTimes = new ArrayList<Life.Memento>();

        Life life = new Life();

        //time travel and record the eras
        life.set("1000 B.C.");
        savedTimes.add(life.saveToMemento());
        life.set("1000 A.D.");
        savedTimes.add(life.saveToMemento());
        life.set("2000 A.D.");
        savedTimes.add(life.saveToMemento());
        life.set("4000 A.D.");

        life.restoreFromMemento((Life.Memento) savedTimes.get(0));
    }
}
```



JDK

- java.util.Date
- java.io.Serializable

Implementation In Python

```python
from copy import copy
from copy import deepcopy


def memento(obj, deep=False):
    state = deepcopy(obj.__dict__) if deep else copy(obj.__dict__)

    def restore():
        obj.__dict__.clear()
        obj.__dict__.update(state)

    return restore

# 手动事务
class Transaction(object):
    deep = False;
    states = []

    def __init__(self, deep, *targets):
        self.deep = deep
        self.targets = targets
        self.commit()

    def commit(self):
        states = [memento(target, self.deep) for target in self.targets]

    def rollback(self):
        for a_store in self.states:
            a_store()

#注解事务
class Transactional(object):
    def __init__(self, method):
        self.method = method

    def __get__(self, obj, T):
        def transaction(*args, **kwargs):
            state = memento(obj)
            try:
                return self.method(obj, *args, **kwargs)
            except Exception as e:
                state()
                raise e


class NumObj(object):
    def __init__(self, value):
        self.value = value

    def __repr__(self):
        return '<%s: %r>' % (self.__class__.__name__, self.value)

    def increment(self):
        self.value += 1

    @Transactional
    def do_stuff(self):
        self.value = '1111'  # <- invalid value
        self.increment()  # <- will fail and rollback


def main():
    num = NumObj(-1)
    print(num)

    transaction = Transaction(True, num)

    try:
        for i in range(3):
            num.increment()
            print(num)
        transaction.commit()
        print("commit")
        num.value += 'aaa'
        print(num)
    except Exception as e:
        transaction.rollback();
        print("rollback")

    try:
        num.do_stuff()
    except Exception as e:
        print('-> doing stuff failed!')
        import sys
        import traceback
        traceback.print_exc(file=sys.stdout)


if __name__ == '__main__':
    main()

```

Summary

1. 备忘录（Memento）存储原发器（Originator）对象的内部状态，在需要时恢复原发器的状态。
2. Memento模式的核心是信息隐藏，即Originator需要向外界隐藏信息，保持其封装性。但同时有需要将状态保持到外界（Memento）。
3. 由于现代语言运行时（C#，java等）都具有相当的独享序列化支持，因此往往采用效率更高、又比较容易正确实现的序列化方案来是想Memento模式。

## 12.2 State (**Behavioral Pattern**)

Motivation

在软件国建过程中，某些对象的状态如果改变，其行为也会随之而发生变化，比如文档处于只读状态，其支持的行为和读写状态支持的行为就可能完全不同。

如何在运行时根据对象的状态来透明地改变对象的行为？而不会为对象操作和状态转化之间引入紧耦合？

Intent

允许一个对象在其内部状态改变时改变它的行为。从而使对象看起来似乎修改了其行为。

Class Diagram

![](pics\State.png)

Implementation In Java

银行账户状态，金额正常状态是银牌会员，超过一定限额，升级为金牌会员，在某一个临界以下是红牌会员。

```java
public interface State {

    void deposit(double amount);

    void withdraw(double amount);

    void payInterest();

    Account getAccount();

    double getBalance();
}
```

```java
public class RedState implements State {
    private Account account;
    private double balance;
    private double upperLimit;
    private double serviceFee;

    public RedState(State state) {
        this(state.getAccount(), state.getBalance());
    }

    public RedState(Account account, double balance) {
        super();
        this.account = account;
        this.balance = balance;
        this.upperLimit = 0.0;
        this.serviceFee = 15.00;
    }

    @Override
    public void deposit(double amount) {
        balance += amount;
        stateChangeCheck();
    }

    @Override
    public void withdraw(double amount) {
        balance = balance - serviceFee;
        System.out.println("No funds available for withdrawal!");
    }

    @Override
    public void payInterest() {
    }

    public Account getAccount() {
        return account;
    }

    public double getBalance() {
        return balance;
    }

    private void stateChangeCheck() {
        if (balance > upperLimit) {
            account.setState(new SilverState(this));
        }
    }
}
```

```java
public class SilverState implements State {

    private Account account;
    private double balance;
    private double interest;
    private double lowerLimit;
    private double upperLimit;

    public SilverState(State state) {
        this(state.getAccount(), state.getBalance());
    }

    public SilverState(Account account, double balance) {
        super();
        this.account = account;
        this.balance = balance;
        this.interest = 0.0;
        this.lowerLimit = 0.0;
        this.upperLimit = 1000.0;
    }


    @Override
    public void deposit(double amount) {
        balance += amount;
        stateChangeCheck();
    }

    @Override
    public void withdraw(double amount) {
        balance -= amount;
        stateChangeCheck();
    }

    @Override
    public void payInterest() {
        balance += interest * balance;
        stateChangeCheck();
    }

    @Override
    public Account getAccount() {
        return this.account;
    }

    @Override
    public double getBalance() {
        return this.balance;
    }

    private void stateChangeCheck() {
        if (balance < lowerLimit) {
            account.setState(new RedState(this));
        } else if (balance > upperLimit) {
            account.setState(new GoldState(this));
        }
    }
}
```

```java
public class GoldState implements State {

    private Account account;
    private double balance;
    private double interest;
    private double lowerLimit;

    public GoldState(State state) {
        this(state.getAccount(), state.getBalance());
    }

    public GoldState(Account account, double balance) {
        super();
        this.account = account;
        this.balance = balance;
        this.interest = 0.05;
        this.lowerLimit = 1000.0;
    }

    @Override
    public void deposit(double amount) {
        balance += amount;
        stateChangeCheck();
    }

    @Override
    public void withdraw(double amount) {
        balance -= amount;
        stateChangeCheck();
    }

    @Override
    public void payInterest() {
        balance += interest * balance;
        stateChangeCheck();
    }

    @Override
    public Account getAccount() {
        return this.account;
    }

    @Override
    public double getBalance() {
        return this.balance;
    }

    private void stateChangeCheck() {
        if (balance < 0.0) {
            account.setState(new RedState(this));
        } else if (balance < lowerLimit) {
            account.setState(new SilverState(this));
        }
    }
}
```

```java
public class Account {

    private State state;
    private String owner;

    // New accounts are 'Silver' by default
    public Account(String owner) {
        super();
        this.state = new SilverState(this, 0.0);
        this.owner = owner;
    }

    public void deposit(double amount) {
        state.deposit(amount);
        System.out.println("Deposited --- "+amount);
        System.out.println("Balance --- "+this.state.getBalance());
        System.out.println("Status --- "+this.state.getClass().getSimpleName());
        System.out.println("--------------------------------");
    }
    public void withdraw(double amount){
        state.withdraw(amount);
        System.out.println("Withdrew --- "+amount);
        System.out.println("Balance --- "+this.state.getBalance());
        System.out.println("Status --- "+this.state.getClass().getSimpleName());
        System.out.println("--------------------------------");
    }
    public void payInterest(){
        state.payInterest();
        System.out.println("Interest Paid --- ");
        System.out.println("Balance --- "+this.state.getBalance());
        System.out.println("Status --- "+this.state.getClass().getSimpleName());
        System.out.println("--------------------------------");
    }
    public void setState(State state) {
        this.state = state;
    }

    public void setOwner(String owner) {
        this.owner = owner;
    }

    public State getState() {
        return state;
    }

    public String getOwner() {
        return owner;
    }

}
```

```java
public class Client {
    public static void main(String[] args) {
        // Open a new account
        Account account = new Account("Dinesh Rajput");
        // Apply financial transactions
        account.deposit(500.0);
        account.deposit(300.0);
        account.deposit(550.0);
        account.payInterest();
        account.withdraw(2000.00);
        account.withdraw(1100.00);
    }
}
```

JDK

- java.util.Iterator
- javax.faces.lifecycle.LifeCycle#execute()

Implementation In Python

```python
class State(object):
    def scan(self):
        self.pos += 1
        if self.pos == len(self.stations):
            self.pos = 0
        print("Scanning ... stations is {} {}".format(self.stations[self.pos], self.name))


class AMState(State):
    def __init__(self, radio):
        self.pos = 0
        self.name = "AM"
        self.radio = radio
        self.stations = ["1250", "1380", "1510"]

    def state_toggle(self):
        print("Switing to FM")
        self.radio.state = self.radio.fmstate


class FMState(State):
    def __init__(self, radio):
        self.pos = 0
        self.name = "FM"
        self.radio = radio
        self.stations = ["81.3", "89.1", "103.9"]

    def state_toggle(self):
        print("Switing to AM")
        self.radio.state = self.radio.amstate


class Radio(object):

    def __init__(self):
        self.fmstate = FMState(self)
        self.amstate = AMState(self)
        self.state = self.amstate

    def scan(self):
        self.state.scan()

    def toggle(self):
        self.state.state_toggle()


def main():
    radio = Radio()
    actions = [radio.scan] * 2 + [radio.toggle] + [radio.scan] * 2

    for action in actions:
        action()


if __name__ == '__main__':
    main()
```

Summary

1. State模式将所有与一个特定状态相关的行为都放入一个State的子类对象中，在对象状态状态切换时，切换相应的对象；但同时维持State的接口，这样实现了具体操作与状态转换之间的解耦。。
2. 为不同的状态引入不同的对象使得状态转移变得更加明确，而且可以保证不会出现不一致的情况，因为转换时原子性的——即要么彻底转换过来，要么不转换。
3. 如果State对象没有实例变量，那么各个上下文可以共享同一个State对象，从而节省对象开销。



# 十三、数据结构

常常有一些组件在内部具有特定的数据结构，如果让客户长须依赖这些特定的数据结构，将极大地破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。

## 13.1 Composite (Structural Pattern)

Motivation

软件在某些情况下，客户代码过多地依赖于对象容器复杂的内部实现结构，对象容器内部实现结构(而非抽象接口)的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展想等弊端。

如何将“客户代码与复杂的对象容器结构”解耦？让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象一样来处理复杂的对象容器？

Intent

将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得客户对单个对象和组合对象的使用具有一致性（稳定）。

Class Diagram

![](pics\Composite.png)

典型结构

![](pics\Composite Typical.png)

Implementation In Java

```java
public interface Employee {
    void showEmployeeDetails();
}
```

```java
public class Developer implements Employee {
    private String name;
    private long empId;
    private String position;


    public Developer(String name, long empId, String position) {
        this.name = name;
        this.empId = empId;
        this.position = position;
    }

    @Override
    public void showEmployeeDetails() {
        System.out.println(this.empId + " " + this.name);
    }
}
```

```java
public class Manager implements Employee {
    private String name;
    private long empId;
    private String position;


    public Manager(String name, long empId, String position) {
        this.name = name;
        this.empId = empId;
        this.position = position;
    }

    @Override
    public void showEmployeeDetails() {
        System.out.println(this.empId + " " + this.name);
    }
}
```

```java
public class CompanyDirectory implements Employee {
    List<Employee> employees = new ArrayList<>();

    @Override
    public void showEmployeeDetails() {
        employees.stream().forEach(e -> e.showEmployeeDetails());
    }

    public void addEmployee(Employee e) {
        employees.add(e);
    }

    public void removeEmployee(Employee e) {
        employees.remove(e);
    }
}
```

```java
public class Company {
    public static void showDetails(Employee employee) {
        employee.showEmployeeDetails();
    }

    public static void main(String[] args) {
        Employee leaf = new Developer("zs",10,"Developer");
        Employee leaf1 = new Manager("ls",11,"CEO");

        CompanyDirectory composite = new CompanyDirectory();
        composite.addEmployee(new Developer("ww",12,"J D"));
        composite.addEmployee(new Manager("zl",13,"CTO"));
        showDetails(composite);
        System.out.println("------------");
        showDetails(leaf);
        System.out.println("--------");
        showDetails(leaf1);
    }
}
```

JDK

- javax.swing.JComponent#add(Component)
- java.awt.Container#add(Component)
- java.util.Map#putAll(Map)
- java.util.List#addAll(Collection)
- java.util.Set#addAll(Collection)

Implementation In Python

```python
class Graphic(object):
    def render(self):
        raise NotImplementedError("You should implement this")


class Composite(Graphic):
    def __init__(self):
        self.graphics = []

    def render(self):
        for graphic in self.graphics:
            graphic.render()

    def add(self, graphic):
        self.graphics.append(graphic)

    def remove(self, graphic):
        self.graphics.remove(graphic)


class Ellipse(Graphic):
    def __init__(self, name):
        self.name = name

    def render(self):
        print("Ellipse: {}".format(self.name))


def main():
    ellipsis1 = Ellipse("1")
    ellipsis2 = Ellipse("2")

    composite = Composite();
    composite.add(ellipsis1)
    composite.add(ellipsis2)
    composite.render()


if __name__ == '__main__':
    main()
```

Summary

1. Composite模式采用树形结构来实现普遍存在的对象容器，从而将“一对多”的关系转化为“一对一”的关系，使得客户代码可一致的（复用）处理对象和对象容器，无需关心处理的对象是单个的对象，还是组合的对象容器。
2. 将“客户代码与复杂的对象容器结构”解耦是Composite的核心思想，解耦之后，客户代码将与纯粹的抽象接口——而非对象容器的内部实现结构——发生依赖，从而更能应对变化。
3. Composite模式在具体实现中，可以让父对象中的子对象反响追溯；如果福对象有频繁的遍历需求，可使用缓存技巧来 改善效率。

## 13.2 Iterator (**Behavioral Pattern**)

Motivation

在软件构建过程中，集合对象内部结构常常变化各异。但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访问其中包含的元素；同时这种“透明遍历”也为“同一种算法在多种集合对象上进行操作”提供了可能。

使用面向对象技术将这种遍历机制抽象为“迭代器对象”为“应对变化中的集合对象”提供了一种优雅的方式。

Intent

提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露（稳定）该对象的内部表示。

Class Diagram

![](C:\Java\IdeaProjects\git\GS-notes\docs\notes\pics\Iterator.png)

Implementation In Java

```java
public interface Iterator<T> {
    T next();
    boolean hasNext();
}
```

```java

public class ConcreteIterator<T> implements Iterator<T> {
    private T[] items;
    private int position;

    public ConcreteIterator(T[] items) {
        this.items = items;
    }

    @Override
    public T next() {
        return items[position++];
    }

    @Override
    public boolean hasNext() {
        return position < items.length;
    }
}
```

```java
public interface Aggregate {
    Iterator createIterator();
}
```

```java
public class ConcreteAggregate implements Aggregate{
    private Integer[] items;

    public ConcreteAggregate() {
        items = new Integer[10];
        for (int i = 0; i < items.length; i++) {
            items[i] = i;
        }
    }

    @Override
    public Iterator createIterator() {
        return new ConcreteIterator<Integer>(items);
    }
}
```

```java
public class Clint {
    public static void main(String[] args) {
        ConcreteAggregate aggregate = new ConcreteAggregate();
        Iterator iterator = aggregate.createIterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }
}
```

JDK

- java.util.Iterator
- java.util.Enumeration

Implementation In Python

```python
def count_to(count):
    numbers = ['one', 'two', 'three', 'four', 'five']
    for number in numbers[:count]:
        yield number


count_to_two = lambda: count_to(2)
count_to_five = lambda: count_to(5)


def main():
    for n in count_to_two():
        print(n)


if __name__ == '__main__':
    main()

```

Summary

1. 迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示。
2. 迭代多态：为遍历不同集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。
3. 迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题。

## 13.3 Chain Of Responsibility (**Behavioral Pattern**)

Motivation

在软件构建过程中，一个请求可能被多个对象处理，但是每个请求在运行时只能有一个接收者，如果现实指定，将比不可少地带来请求发送者和接收者的紧耦合。

如何使请求的发送者不需要指定具体的接收者？让请求的接收者自己在运行时决定来处理请求，从而使两者解耦。

Intent

使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将在这些对象连成一条链，沿着这条链传递请求，知道有一个对象处理它为止。

Class Diagram

![](pics\Chain Of Responsibility.png)

一个典型的实例

![](pics\Chain Of Responsibility Demo.png)

Implementation In Java

```java
public enum  RequestType {
    DEFEND_CASTLE, TORTURE_PRISONER, COLLECT_TAX
}
```

```java
public class Request {
    private final RequestType requestType;
    private String requestDescription;
    private boolean handled;

    public Request(RequestType requestType, String requestDescription) {
        this.requestType = requestType;
        this.requestDescription = requestDescription;
    }

    public void makeHandled() {
        this.handled = true;
    }

    public boolean isHandled() {
        return this.handled;
    }

    public RequestType getRequestType() {
        return this.requestType;
    }

    public String getRequestDescription() {
        return this.requestDescription;
    }

    @Override
    public String toString() {
        return getRequestDescription();
    }
}
```

```java
public abstract class RequestHandler {
    private static final Logger LOGGER = LoggerFactory.getLogger(RequestHandler.class);
    private RequestHandler next;

    public RequestHandler(RequestHandler next) {
        this.next = next;
    }

    public void handleRequest(Request req) {
        if (next != null) {
            next.handleRequest(req);
        }
    }

    public void printHandler(Request req) {
        LOGGER.info("{} handle request \"{}\"", this, req);
    }

    @Override
    public abstract String toString();
}
```

```java
public class OrcKing {
    RequestHandler chain;

    public OrcKing() {
        buildChain();
    }

    public void buildChain(){
        chain = new OrcCommander(new OrcOfficer(new OrcSoldier(null)));
    }

    public void makeRequest(Request req){
        chain.handleRequest(req);
    }
}

```

```java
public class OrcOfficer extends RequestHandler{
    public OrcOfficer(RequestHandler next) {
        super(next);
    }

    @Override
    public void handleRequest(Request req) {
        if(RequestType.TORTURE_PRISONER.equals(req.getRequestType())){
            printHandler(req);
            req.makeHandled();
        }else {
            super.handleRequest(req);
        }
    }

    @Override
    public String toString() {
        return "Orc Officer";
    }
}
```

```java
public class OrcSoldier extends RequestHandler {
    public OrcSoldier(RequestHandler next) {
        super(next);
    }

    @Override
    public void handleRequest(Request req) {
        if (RequestType.COLLECT_TAX.equals(req.getRequestType())) {
            printHandler(req);
            req.makeHandled();
        } else
            super.handleRequest(req);
    }

    @Override
    public String toString() {
        return "Orc Soldier";
    }
}
```

```java
public class OrcCommander extends RequestHandler {
    public OrcCommander(RequestHandler next) {
        super(next);
    }

    @Override
    public void handleRequest(Request req) {
        if (RequestType.DEFEND_CASTLE.equals(req.getRequestType())) {
            printHandler(req);
            req.makeHandled();
        } else {
            super.handleRequest(req);
        }
    }

    @Override
    public String toString() {
        return "Orc Commander";
    }
}
```

```java
public class App {
    public static void main(String[] args) {
        OrcKing king = new OrcKing();
        king.makeRequest(new Request(RequestType.COLLECT_TAX, "collect tax"));
        king.makeRequest(new Request(RequestType.TORTURE_PRISONER, "torture prisoner"));
        king.makeRequest(new Request(RequestType.DEFEND_CASTLE, "defend castle"));
    }
}
```

JDK

- **java.util.logging.Logger#log()**
- **javax.servlet.Filter#doFilter()**

Implementation In Python

```python
import abc


class Handler(object):
    __metaclass__ = abc.ABCMeta

    def __init__(self, successor=None):
        self.successor = successor

    def handle(self, request):
        res = self.check_range(request)
        if not res and self.successor:
            self.successor.handle(request)

    @abc.abstractmethod
    def check_range(self, request):
        """将参数值与预设值进行比较"""


class ConcreteHandler0(Handler):
    """Each handler can be different.
       Be simple and static...
       """

    @staticmethod
    def check_range(request):
        if 0 < request > 10:
            print("request {} handled in handler0 ".format(request))
            return True


class ConcreteHandler1(Handler):
    """... With it's own internal state"""

    start, end = 10, 20

    def check_range(self, request):
        if self.start <= request < self.end:
            print("request {} handled in handler 1".format(request))
            return True


class ConcreteHandler2(Handler):
    """... With helper methods."""

    def check_range(self, request):
        start, end = self.get_interval_from_db()
        if start <= request < end:
            print("request {} handled in handler 2".format(request))
            return True

    @staticmethod
    def get_interval_from_db():
        return (20, 30)


class FallbackHandler(Handler):
    @staticmethod
    def check_range(request):
        print("end of chain, no handler for {}".format(request))
        return False


def main():
    h0 = ConcreteHandler0()
    h1 = ConcreteHandler1()
    h2 = ConcreteHandler2(FallbackHandler())
    h1.successor = h2
    h0.successor = h1
    for request in [2, 12, 22, 32, 25, 15, 5]:
        h0.handle(request)


if __name__ == '__main__':
    main()
```

Summary

1. Chain Of Responsibility模式的应用场合在于“一个请求可能有多个接收者，但是最后真正的接收者只有一个”，这时候请求发送者与接收者的耦合有可能出现“变化脆弱”的症状，职责链的目的就是将二者解耦，从而更好的应对变化。
2. 应用了Chain Of Responsibility模式后，对象的职责分派将更具灵活性。我们可以在运行时动态添加/修改请求的处理职责。
3. 如果请求传递到职责链的末尾仍得不到处理，应该有一个合理的缺省机制。这也是每一个接受对象的职责，而不是发出请求的对象的职责。

# 十四、行为变化

## 14.1 Command (**Behavioral Pattern**)

在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。“行为变化”模式将组件的行为和组件本身进行解耦，从而支持组件行为的变化，时效件两者之间的松耦合。

Motivation

在软件构建过程中，“行为请求这”与“行为实现者”通常呈现出一种“紧耦合”。但在某些场合——比如需要对行为进行“记录、撤销/重(undo/redo)、事务“等处理，这种无法抵御变化的紧耦合是不适合的。

在这种情况下，如何将“行为请求这”与“行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。

Intent

将一个请求（行为）封装到一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。

Class Diagram

![](pics\Command.png)

Implementation In Java

```java
public interface Command {
    void execute();
}
```

```java
public class Stereo {
    public void on() {
        System.out.println("Stereo is on");
    }

    public void off() {
        System.out.println("Stereo is off");
    }

    public void setCD() {
        System.out.println("Stereo is set for CD input");
    }

    public void setDVD() {
        System.out.println("Stereo is set for DVD input");
    }

    public void setRadio() {
        System.out.println("Stereo is set for Radio");
    }

    public void setVolume(int volume) {
        System.out.println("Stereo volume set to " + volume);
    }
}
```

```java
public class StereoOffCommand implements Command {
    Stereo stereo;
    public StereoOffCommand(Stereo stereo)
    {
        this.stereo = stereo;
    }
    public void execute()
    {
        stereo.off();
    }
}
```

```java
public class StereoOnWithCDCommand implements Command{
    Stereo stereo;
    public StereoOnWithCDCommand(Stereo stereo)
    {
        this.stereo = stereo;
    }
    public void execute()
    {
        stereo.on();
        stereo.setCD();
        stereo.setVolume(11);
    }
}
```

```java
public class SimpleRemoteControl {
    Command command;

    public SimpleRemoteControl() {
    }

    public void setCommand(Command command) {
        this.command = command;
    }

    public void buttonWasPressed() {
        command.execute();
    }
}
```

```java
public class Client {
    public static void main(String[] args) {
        SimpleRemoteControl control = new SimpleRemoteControl();
        Stereo stereo = new Stereo();
        control.setCommand(new StereoOnWithCDCommand(stereo));
        control.buttonWasPressed();
    }
}
```



JDK

- java.lang.Runnable
- javax.swing.Action

Implementation In Python

```python
import os


class MoveFileCommand(object):
    def __init__(self, src, dest):
        self.src = src
        self.dest = dest

    def execute(self):
        self.rename(self.src, self.dest)

    def undo(self):
        self.rename(self.dest, self.src)

    def rename(self, src, dest):
        os.rename(src, dest)


def main():
    c = MoveFileCommand('a.txt', 'c.txt')
    # c.execute()
    c.undo()


if __name__ == '__main__':
    main()
```

Summary

1. Command模式的根本目的在于将“行为请求者”与“行为实现者“解耦，在面向对象语言中，常见的实现手段是”将行为抽象为对象“。
2. 实现Command接口的具体命令对象ConcreteCommand有时候根据需要可能会保存一些额外的状态信息。通过使用Composite模式，可以将多个“命令’分装为一个”复合命令“MacroCommand。

## 14.2 Visitor (**Behavioral Pattern**)

Motivation

在软件构建过程中，有需求的改变，某些类层次结构中常常需要增加新的行为（方法），如果直接在基类中做这样的更改，将会给子类带来很繁重的变更负担，甚至破坏原有设计。

如何在不更改类层次结构的前提下，在运行时根据需要透明地为类层次结构上的各个类动态添加新的操作，从而避免上述问题？

Intent

表示一个作用于某个对象结构中的各元素的操作。使得可以在不改变（稳定）各元素的类的前提下定义（扩展）作用于这些元素的新操作（变化）。

Class Diagram

这一模式的条件相当于比较苛刻，他要求element及其子类都要稳定，其实有时候不太容易满足。

![](pics\Visitor.png)

Implementation In Java

```java
public interface ItemElement {
    double accept(ShoppingCartVisitor visitor);
}
```

```java
public class Book implements ItemElement{
    private double price;
    private String isbnNumber;

    public Book(double price, String isbnNumber) {
        this.price = price;
        this.isbnNumber = isbnNumber;
    }

    public double getPrice() {
        return price;
    }

    public String getIsbnNumber() {
        return isbnNumber;
    }

    @Override
    public double accept(ShoppingCartVisitor visitor) {
        return visitor.visit(this);
    }
}
```

```java
public class Fruit implements ItemElement {
    private double pricePerKg;
    private double weight;
    private String name;

    public Fruit(double pricePerKg, double weight, String name) {
        this.pricePerKg = pricePerKg;
        this.weight = weight;
        this.name = name;
    }

    public double getPricePerKg() {
        return pricePerKg;
    }

    public double getWeight() {
        return weight;
    }

    public String getName() {
        return name;
    }

    @Override
    public double accept(ShoppingCartVisitor visitor) {
        return visitor.visit(this);
    }
}
```

```java
public interface ShoppingCartVisitor {
    double visit(Book book);

    double visit(Fruit fruit);
}
```

```java
public class ShoppingCartVisitorImpl implements ShoppingCartVisitor {
    @Override
    public double visit(Book book) {
        double cost = 0;
        if (book.getPrice() > 50) {
            cost = book.getPrice() - 5;
        } else
            cost = book.getPrice();

        System.out.println("Book ISBN::" + book.getIsbnNumber() + " cost =" + cost);
        return cost;
    }

    @Override
    public double visit(Fruit fruit) {
        double cost = fruit.getPricePerKg() * fruit.getWeight();
        System.out.println(fruit.getName() + " cost = " + cost);
        return cost;
    }
}
```

```java
public class Client {
    public static void main(String[] args) {
        ItemElement[] items = new ItemElement[]{
                new Book(100,"1234"),
                new Book(200,"5678"),
                new Fruit(10,5,"apple"),
                new Fruit(45,3,"banana")
        };
        
        ShoppingCartVisitor visitor = new ShoppingCartVisitorImpl();
        for (ItemElement item : items) {
            item.accept(visitor);
        }
    }
}
```

JDK

- javax.lang.model.element.Element and javax.lang.model.element.ElementVisitor
- javax.lang.model.type.TypeMirror and javax.lang.model.type.TypeVisitor

Implementation In Python

```python
class Node(object):
    pass


class A(Node):
    pass


class B(Node):
    pass


class C(A, B):
    pass


class Visitor(object):
    def visit(self, node, *args, **kwargs):
        meth = None
        for cls in node.__class__.__mro__:
            meth_name = 'visit_' + cls.__name__
            meth = getattr(self, meth_name, None)
            if meth:
                break
        if not meth:
            meth = self.generic_visit

        return meth(node, *args, **kwargs)

    def generic_visit(self, node, *args, **kwargs):
        print("generic_visit ", node.__class__.__name__)

    def visit_B(self, node, *args, **kwargs):
        print("visit_B ", node.__class__.__name__)


def main():
    a, b, c = A(), B(), C()

    visitor = Visitor()
    visitor.visit(a)
    visitor.visit(b)
    visitor.visit(c)


if __name__ == '__main__':
    main()

```

Summary

1. Visitor模式通过所谓的双重分发（double dispatch）来实现在不更改（不添加新的操作——编译时）Element类层次结构的前提下，在运行时透明地位类层次结构上的各个类动态添加新的操作（支持变化）。
2. 所谓双重分发即Visitor模式中间包括了两个多态分发（注意其中的多态机制）：第一个为accept方法的多态辨析；第二个为visitElementX方法的多态辨析。
3. Visitor模式的最大缺点在于扩展类层次结构（增添新的Element子类），会导致Visitor类的改变。因此Visitor模式适用于Element类层次结构稳定，而其中的操作却经常面临频繁的改动。

# 十五、领域问题

在特定领域中，某些变化虽然频繁，但可以抽象为某种规则。这时候，结合特定领域，将问题抽象为语法规则，从而给出在该领域下的一般性的解决方案。

## 15.1 Interpreter (**Behavioral Pattern**)

Motivation

在软件构建过程中，如果某一特定领域的问题比较复杂，类似的结构不断重复出现，如果使用普通的编程方式来实现将面临非常频繁的变化。

在这种情况下，将特定领域的问题表达为某种语法规则下的句子，然后构建一个解释器来解释这样的句子，从而达到解决问题的目的。

Intent

给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释语言中的句子。

Class Diagram

![](pics\Interpreter.png)

Implementation In Java

```java
public interface Expression {
    boolean interpreter(String con);
}
```

```java
public class TerminalExpression implements Expression {
    String data;

    public TerminalExpression(String data) {
        this.data = data;
    }

    @Override
    public boolean interpreter(String con) {
        if (con.contains(data)) {
            return true;
        } else {
            return false;
        }
    }
}
```

```java
public class OrExpression implements Expression{
    Expression exp1;
    Expression exp2;

    public OrExpression(Expression exp1, Expression exp2) {
        this.exp1 = exp1;
        this.exp2 = exp2;
    }

    @Override
    public boolean interpreter(String con) {
        return exp1.interpreter(con) || exp2.interpreter(con);
    }
}
```

```java
public class AndExpression implements Expression {
    Expression exp1;
    Expression exp2;

    public AndExpression(Expression exp1, Expression exp2) {
        this.exp1 = exp1;
        this.exp2 = exp2;
    }

    @Override
    public boolean interpreter(String con) {
        return exp1.interpreter(con) && exp2.interpreter(con);
    }
}
```

```java
public class Client {
    public static void main(String[] args) {
        TerminalExpression person1 = new TerminalExpression("zs");
        TerminalExpression person2 = new TerminalExpression("ws");
        
        OrExpression or = new OrExpression(person1, person2);
        System.out.println(or.interpreter("zs"));

        OrExpression and = new OrExpression(person1, person2);
        System.out.println(and.interpreter("zs,ws"));
    }
}
```

JDK

-  java.util.Pattern
-  java.text.Normalizer
-  java.text.Format



Summary

1. Interpreter模式的应用场合是Interpreter模式应用中的难点，只有满足“业务规则频繁变化，且类似的结构不断重复出现，并且容易抽象为语法规则的问题”才适合使用Interpreter模式。
2. 使用Interpreter模式来表示文法规则，从而可以使用面向对象技巧来方便地“扩展”文法。
3. Interpreter模式比较适合简单的文法表示，对于复杂的文法表示，Interpreter模式会产生比较大的类层次结构，需要求助于语法分析生成器这样的标准工具。



# 创建型模式

- 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
- 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
- 工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
- 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
- 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。

# 结构型模式

1. 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
2. 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
3. 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。
4. 装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。
5. 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
6. 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
7. 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。

# 行为型模式

1. 模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
2. 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
3. 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
4. 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
5. 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
6. 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
7. 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
8. 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
9. 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
10. 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
11. 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。



# 不常用（课程是c++)：

builder，mediator，memento，Iterator，chain of responsibility，command，visitor，interpreter

# headFirst 重点讲解的模式：

observer，decorator，Factory，singleton，Command，adapter，facade，template method，Iterator，Composite，State，Proxy

# 参考资料

- Java 编程思想
- GeekBand C++ 设计模式 李建忠
- 弗里曼. Head First 设计模式 [M]. 中国电力出版社, 2007.
- Gamma E. 设计模式: 可复用面向对象软件的基础 [M]. 机械工业出版社, 2007.
- 精通Python设计模式[M].人民邮电出版社, 2016.
- [python-patterns](https://github.com/faif/python-patterns)
- [面向对象思想](https://cyc2018.github.io/CS-Notes/#/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3)
- [面向对象设计的 SOLID 原则](http://www.cnblogs.com/shanyou/archive/2009/09/21/1570716.html)
- [[JAVA设计模式总结之23种设计模式](https://www.cnblogs.com/pony1223/p/7608955.html)]
- [看懂 UML 类图和时序图](http://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html#generalization)
- [UML 系列——时序图（顺序图）sequence diagram](http://www.cnblogs.com/wolf-sun/p/UML-Sequence-diagram.html)
- [Design Patterns](http://www.oodesign.com/)
- [Design patterns implemented in Java](http://java-design-patterns.com/)
- [The breakdown of design patterns in JDK](http://www.programering.com/a/MTNxAzMwATY.html)
- [Builder Design Pattern](https://www.geeksforgeeks.org/builder-design-pattern/)
- [State Pattern Design](https://www.dineshonjava.com/state-pattern/)

