# 1. Redis 是什么？它的优缺点有哪些？

Redis 是一个 key-value 存储系统。支持存储的value类型包括：string(字符串)、list(列表)、set(集合)、zset(sorted-set，有序集合)和hash(哈希类型)。

这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。

Redis支持各种方式的排序，数据都是缓存到内存中。Redis会周期性的把更新的数据写入磁盘或者写入追加的记录文件，并且在此基础上实现了Master-Slave主从同步。

Redis是一个高性能的key-value数据库。在部分场合可以对关系数据库起到很好的补充作用。他提供了Java、C/C++、C#、PHP、JavaScript、Perl、Object-C、Python、Ruby、Erlang等客户端。

因为是存内存操作，Redis的性能非常出色，每秒可以处理超过10万次读写操作，是已知性能最快的key-valueDB。

Redis的出色之处不仅仅是性能，Redis最大的魄力是支持保存多种数据结构，此外单个value能存非常多的数据。比如：list来做FIFO双向链表，实现一个轻量级的高性能消息队列服务，用它的Set可以做高性能的tag系统等等。

另外Redis也可以对存入的key-value设置expire时间。

Redis的缺点是：数据容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小的数据量的高性能操作和运算上。

Redis支持主从同步。数据可以从主服务器想任意数量的从服务器上同步，从服务器可以使关联其他从服务器的主服务器。这使得Redis可执行单层树复制。存盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何定法同步树时，可订阅一个频道并接收主服务器的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。

# 2. Redis 相比Memcache有哪些优势？

1. Memcache所有的值均是简单的字符串
2. Redis作为其替代者，支持丰富的数据类型
3. Redis的速度比Memcache要更快
4. Redis可以持久化其数据
5. Redis能存非常多的数据，而Memcache只能保存1M的数据

# 3. Redis支持哪些数据结构？

字符串 String、字典 Hash、列表 List、集合 Set、有序集合 SortedSet。剩下的如：HyperLogLog、Geo、Pub/Sub、Redis Module，BloomFilter，RedisSearch，Redis-ML 也都可以讲一讲。

# 4. Redis的全称是什么？

Remote Directory Server

# 5.说说Redis分布式锁的使用过程是怎样的？

先拿setnx来争夺锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。但是这个过程有一个致命的问题，如果在setnx之后执行expire之前进程意外crash或者要重启维护了。那这个锁就永远得不到释放了。所以应该同时把setnx和expire合成一条指令来使用。

# 6. 说说Redis的几种数据淘汰策略？

1. noeviction：

   禁止淘汰数据

2. allkeys-lru：尝试收回最少使用的键（LRU），使得添加的数据有空间存放。

3. volatile-lru；尝试回收最少使用的键（LRU），但仅限于在过期集合的键，使得添加的数据有空间存放。

4. allkeys-random：回收随机的键，使得新添加的数据有空间存放。

5. volatile-random：回收随机的键，但仅限于在过期的集合的键，使得新添加的数据有空间存放。

6. volatile-ttl：回收在过期集合的键，并优先回收存活时间（TTL）较短的键，使得新添加的数据有空间存放。

# 7. Redis官方为什么不提供Windows版本？

因为目前Linux版本已经相当稳定，而且用户量很大，开发Windows版本，反而会带来兼容性等问题。

# 8. 如何找出某个固定的已知的前缀开头的可以？比如10亿个里面找出10w个。

使用 keys 指令可以扫除指定模式的 key 列表。但是在线上，这个命令一般会被禁止了。因为它是一个阻塞命令。

推荐使用 scan 命令，scan 命令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复率，在客户端来做一次**去重**就可以了，但是整体花费的时间会比直接用 keys 指令长。

# 9. 一个字符串类型的值能存储最大容量是多少？

512M

# 10. 如果有大量的 key 需要设置同一时间过期，一般需要注意什么？

如果大量的 key 过期时间设置的过于集中，到过期的那个时间点Redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机数，使得过期时间分散一些。

# 11. Redis集群方案应该怎么做？都有哪些方案？

1. [condis ](https://www.cnblogs.com/shanyou/p/4268896.html) 是开源的，目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在节点数量改变的情况下，旧节点数据可恢复到新hash节点。
2. Redis Cluster 3.0自带的集群，特点在于它的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。
3. 从业务代码层实现，起几个毫无相关的redis实例，在代码层，对key进行hash计算，然后去对应的redis实例操作数据。这种方式对hash层代码要求比价高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控等等。

# 12. bgsave做镜像全量持久化的原理是什么？

fork和cow。

fork是指redis通过创建子进程来进行bgsave操作。

cow是指 copy on write ，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面会逐渐和子进程分离开来。

# 13. Pipeline 有什么好处，为什么要用pipeline？

可以将多次IO往返的时间缩减为一次，前提是pipeline进行的指令间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要原因是pipeline批次指令的数目。

# 14. Redis 同步机制是什么？

Redis 可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存Buffer中，待完成后，将rdb文件全量同步到复制节点，复制节点接收完成后将rdb镜像加载到内存。加载完成后，再通知主节点的将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。

# 15. 是否使用过Redis集群，集群的原理是什么？

Redis Sentinel着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。

Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。

# 16. Jedis 与 Redisson 对比有什么优缺点？

Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持；

Redisson 实现了分布式和可扩展的 Java 数据结构， 和 Jedis相比，功能比较简单，不支持字符串的操作，不支持排序、事务、管道、分区等 Redis 特性。 Redisson 的宗旨是促使使用者对 Redis 的关注分离，从而让使用者能够将经历更集中地放在要处理的业务逻辑上。

# 17. 说说Redis哈希槽的概念？

Redis 集群没有使用一致性hash，而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点富足一部分hash槽。

# 18. Redis 集群会有写操作丢失吗？

Redis并不能保证数据的强一致性，这意味着在实际中集群在特定的条件下可能会丢失写操作。

# 19. Redis 集群如何选在数据库？

Redis集群目前无法做数据库的选择，默认在0数据库

# 20. 怎么理解Redis事务？

事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行过程中，不会被其他客户端发来的命令请求中断。

事务是一个原子操作：事务中的命令要么全部执行，要么全部都不执行。

通常使用MULTI、EXEC、DISCARD、WATCH这几个命令操作事务。

# 21. 什么是缓存穿透？如何避免？什么是缓存雪崩？如何避免？

缓存穿透：一般的缓存系统，都是按照 key 去缓存查询，如果不存在对应的 value ，就应该去后端系统查找（比如DB）。一些恶意的请求故意查询不存在的 key ，请求量很大，就会对后端系统造成很大的压力。

避免方法：

1. 对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该 key 对应的数据 insert 了之后清理缓存。

2. 对一定不存在的 key 进行过滤。

   可以把所有的可能存在的 key 方法一个大的 Bitmap中，查询时通过该 bitmap 过滤。

缓存雪崩：当缓存服务器重启或者大量缓存集中在摸一个时间段失效，这样在失效的时候，会给后端系统带来很大的压力。导致系统崩溃。

避免方法：

1. 在缓存失效后，通过加锁的或者队列来控制读数据库写缓存的线程数量。比如：对某个 key 只允许一个线程查询数据和写缓存，其他线程等待
2. 做二级缓存，A1 为原始缓存，A2 为拷贝缓存，A1 失效时，可以访问 A2 ， A1 缓存的失效时间设置为短期，A2设置为长期。
3. 不同的 key ，设置不同的过期时间，让缓存失效的时间点尽量均匀。



# redis底层实现-跳表，比红黑树好在哪？